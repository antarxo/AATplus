<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Î˜ÎµÎ±Ï„ÏÎ¹ÎºÎ® Î£ÎºÎ·Î½Î® â€” Î•Î½Î¹Î±Î¯Î± ÎˆÎºÎ´Î¿ÏƒÎ· (Act I + Act II + Î¦Î¿Ï…Î±Î³Î¹Î­)</title>

  <!-- uPlot Î³Î¹Î± xâ€“t (Ï€Î±ÏÎ±Î¼Î­Î½ÎµÎ¹, Ï€Î±ÏÏŒÏ„Î¹ Ï„ÏÏÎ± Ï„Î¿ xâ€“t ÎµÎ¯Î½Î±Î¹ Î´Î¹ÎºÏŒ Î¼Î±Ï‚ canvas) -->
  <link rel="stylesheet" href="https://unpkg.com/uplot@1.6.30/dist/uPlot.min.css">
  <script src="https://unpkg.com/uplot@1.6.30/dist/uPlot.iife.min.js"></script>

  <!-- CSS ÏƒÎºÎ·Î½Î®Ï‚ -->
  <link rel="stylesheet" href="./aat-stage.css">

  <!-- AAT responsive scaler (baseline + uniform scale on .stage) -->
  <script>
  
function num(v,fallback=0){
  const n=(typeof v==='number') ? v : (typeof v==='string' ? parseFloat(v) : NaN);
  return Number.isFinite(n) ? n : fallback;
}
(function(){
    const root = document.documentElement;
    const p = new URLSearchParams(location.search);

    const DW = parseFloat(p.get('dw')) || 1403;
    const DH = parseFloat(p.get('dh')) || 648;
    const mode = (p.get('mode') || 'contain').toLowerCase();

    function viewport(){
      const vv = window.visualViewport;
      const vw = vv ? vv.width  : (window.innerWidth  || root.clientWidth  || 0);
      const vh = vv ? vv.height : (window.innerHeight || root.clientHeight || 0);
      return {vw, vh};
    }

    function pickScale(vw, vh){
      const sx = vw / DW;
      const sy = vh / DH;
      if(mode === 'cover') return Math.max(sx, sy);
      if(mode === 'fillw') return sx;
      if(mode === 'fillh') return sy;
      return Math.min(sx, sy); // contain default
    }

    function apply(){
      const {vw, vh} = viewport();
      if(!vw || !vh) return;
      const s = pickScale(vw, vh);
      root.style.setProperty('--aat-dw', DW);
      root.style.setProperty('--aat-dh', DH);
      root.style.setProperty('--aat-scale', (Math.max(0.01, s)).toFixed(6));
          const vv = window.visualViewport;
      const vvw = vv ? vv.width  : (window.innerWidth  || 0);
      const vvh = vv ? vv.height : (window.innerHeight || 0);
      const offX = vv ? vv.offsetLeft : 0;
      const offY = vv ? vv.offsetTop  : 0;
      root.style.setProperty('--aat-vvw', Math.round(vvw) + 'px');
      root.style.setProperty('--aat-vvh', Math.round(vvh) + 'px');
      root.style.setProperty('--aat-vvoffx', Math.round(offX) + 'px');
      root.style.setProperty('--aat-vvoffy', Math.round(offY) + 'px');
}

    window.addEventListener('resize', apply, {passive:true});
    if(window.visualViewport) window.visualViewport.addEventListener('resize', apply, {passive:true});
    document.addEventListener('DOMContentLoaded', apply);
    apply();
  })();
  </script>


  <!-- Intro veil (ÎµÎ½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½Î¿ ÏƒÏ„Î¿ index) -->
  <style>
    body.intro-open { overflow: hidden; }

/* ÎŒÏƒÎ¿ ÎµÎ¯Î½Î±Î¹ Î±Î½Î¿Î¹Ï‡Ï„ÏŒ Ï„Î¿ intro, ÎºÏÏÎ²Î¿Ï…Î¼Îµ Ï„Î± â€œÏ‡ÎµÎ¹ÏÎ¹ÏƒÏ„Î®ÏÎ¹Î±â€ Ï„Î·Ï‚ ÏƒÎºÎ·Î½Î®Ï‚ Î³Î¹Î± Î½Î± Î¼Î·Î½ Ï†Î±Î¯Î½Î¿Î½Ï„Î±Î¹ Ï€Î¯ÏƒÏ‰ Î±Ï€ÏŒ Ï„Î¿ Ï€Î­Ï€Î»Î¿ */
    body.intro-open .lang-toggle,
    body.intro-open .signboard,
    body.intro-open .clock,
    body.intro-open #measureBox,
    body.intro-open #laws,
    body.intro-open #countdownOverlay,
    body.intro-open #actBreakOverlay,
    body.intro-open #foyerBreakOverlay,
    body.intro-open #startBtn,
    body.intro-open #startBreak,
    body.intro-open #btnPause,
    body.intro-open #btnPlay,
    body.intro-open #btnReset,
    body.intro-open #btnFoyer,
        body.intro-open #btnNav,
    body.intro-open #btnNext,
    body.intro-open #navBreak,
    body.intro-open #btnBook,
    body.intro-open #foyerBubble,
    body.intro-open #xtMiniCanvas,
    body.intro-open #btnXTmini{
      visibility: hidden !important;
    }

    #introOverlay.intro-veil{
      position: fixed;
      inset: 0;
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
      overflow: hidden;           /* Î³Î¹Î± Î½Î± â€œÎºÏŒÎ²ÎµÏ„Î±Î¹â€ Ï„Î¿ blur layer */
      isolation: isolate;         /* ÏƒÏ‰ÏƒÏ„ÏŒ layering Ï„Ï‰Î½ ::before/::after */
      background: transparent;    /* Ï„Î¿ Ï†ÏŒÎ½Ï„Î¿ Ï„Î¿ Ï†Ï„Î¹Î¬Ï‡Î½Î¿Ï…Î½ Ï„Î± pseudo-elements */
    }

    /* blurred BG Î±Ï€ÏŒ Ï„Î·Î½ Î¯Î´Î¹Î± Ï„Î·Î½ Ï„Î±Î¼Ï€Î­Î»Î± (posterSrc) */
    #introOverlay.intro-veil::before{
      content:'';
      position:absolute;
      inset:-40px;
      background-color:#000;
      background-image: var(--intro-bg, none);
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      filter: blur(18px) saturate(1.12);
      transform: scale(1.08);
      opacity: .90;
      z-index: 0;
      pointer-events:none;
    }

    /* dark overlay Î³Î¹Î± Î½Î± â€œÎºÎ¬Ï„ÏƒÎµÎ¹â€ Ï„Î¿ Ï‡Î±ÏÏ„Î¯/ÎºÎµÎ¯Î¼ÎµÎ½Î¿ */
    #introOverlay.intro-veil::after{
      content:'';
      position:absolute;
      inset:0;
      background:
        radial-gradient(circle at 50% 25%, rgba(0,0,0,.15) 0%, rgba(0,0,0,.85) 70%),
        linear-gradient(180deg, rgba(0,0,0,.20) 0%, rgba(0,0,0,.88) 100%);
      z-index: 1;
      pointer-events:none;
    }
    #introOverlay.hidden{ display:none; }

    #introOverlay .intro-card{
      position: relative;
      z-index: 2;
      width: min(980px, 100%);
      max-height: min(92vh, 980px);
      border-radius: 18px;
      padding: 18px 18px 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,.38);
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(222, 238, 222, .96); /* Ï€ÏÎ±ÏƒÎ¹Î½Ï‰Ï€ÏŒ â€œÏ‡Î±ÏÏ„Î¯â€ */

      /* Î£Î·Î¼Î±Î½Ï„Î¹ÎºÏŒ: Î½Î± ÎœÎ—Î Î³Î¯Î½ÎµÏ„Î±Î¹ scroll ÏŒÎ»Î· Î· ÎºÎ¬ÏÏ„Î± â€” Î¼ÏŒÎ½Î¿ Ï„Î¿ ÎºÎµÎ¯Î¼ÎµÎ½Î¿ */
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #introOverlay .intro-poster{
      width: 100%;
      height: auto;
      max-height: 28vh;
      object-fit: contain;
      display: block;
      border-radius: 12px;
      margin: 0 0 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.18);
      flex: 0 0 auto;
    }

    #introOverlay .intro-leaflet{
      font-family: Georgia, "Times New Roman", serif;
      font-size: 16.5px;
      line-height: 1.45;
      color: #142015;

      /* ÎµÎ´Ï Î³Î¯Î½ÎµÏ„Î±Î¹ Ï„Î¿ scroll */
      flex: 1 1 auto;
      overflow: auto;
      padding-right: 6px;
    }

    #introOverlay .intro-leaflet p{
      margin: 0 0 10px;
      text-align: justify;
      text-justify: inter-word;
    }

    #introOverlay .intro-leaflet .leaflet-ul{
      margin: 6px 0 10px 22px;
      padding: 0;
    }
    #introOverlay .intro-leaflet .leaflet-ul > li{
      margin: 6px 0;
    }
    #introOverlay .intro-leaflet .leaflet-sub{
      margin: 6px 0 0 18px;
      padding: 0;
      list-style-type: circle;
    }

    #introOverlay .intro-continue{
      margin: 14px auto 0;
      display: inline-block;
      padding: 10px 18px;
      border-radius: 12px;
      border: 0;
      cursor: pointer;
      font-weight: 800;
      background: #2f7a45;
      color: #fff;
      box-shadow: 0 10px 22px rgba(0,0,0,.22);
      flex: 0 0 auto;
    }
    
    .intro-lang{
      display:flex;
      gap:10px;
      justify-content:center;
      align-items:center;
      margin:10px 0 6px;
      flex-wrap:wrap;
    }
    .intro-lang-btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.25);
      background: rgba(0,0,0,.22);
      color:#fff;
      border-radius:999px;
      padding:7px 12px;
      font-size:.92rem;
      font-weight:700;
      cursor:pointer;
      backdrop-filter: blur(6px);
    }
    .intro-lang-btn:hover{ background: rgba(0,0,0,.32); }
    .intro-lang-btn.active{
      background: rgba(255,255,255,.16);
      border-color: rgba(255,255,255,.55);
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
#introOverlay .intro-continue:hover{ filter: brightness(1.05); }
  

  /* --- Strobe (stop-motion) Î±Ï€Î¿Ï‡ÏÏÎ·ÏƒÎ· ÏƒÏ„Î¿ Î¦Î¿Ï…Î±Î³Î¹Î­ --- */
  .strobe-curtain{
    position:fixed;
    inset:0;
    background:#000;
    opacity:1;
    display:none;
    z-index:10000;
    pointer-events:none;
    transition: opacity 0ms linear;
  }
  body.strobe-active .strobe-curtain{ display:block; }
  body.strobe-active .viewer-avatar{ transition:none !important; }

/* Teaser tag Î³Î¹Î± â€œÎ ÏÎ¬Î¾Î· 3â€ (Î±Î´ÏÎ±Î½Î­Ï‚) + Î±Ï€Î¿Ï‡ÏÏÎ·ÏƒÎ· Î¼Î±Ï…ÏÎ¿Ï€Î¯Î½Î±ÎºÎ± */
.act3-teaser{
  position:absolute;
  right:18px;
  top:12px;
  padding:8px 12px;
  border-radius:12px;
  background:rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.18);
  color:#fff;
  font-weight:800;
  letter-spacing:.2px;
  opacity:.65;
  pointer-events:none;
  display:none;
}
.foyer .wrap.foyer-board-exit{
  transition: transform 900ms ease, opacity 900ms ease;
  transform: translateX(120px);
  opacity:0;
}


/* =========================
   Driver sliders (Phase 3)
   ========================= */
.drive-controls{
  position:absolute;
  bottom:56px;           /* Ï€Î¬Î½Ï‰ Î±Ï€ÏŒ Ï„Î¿ ÎºÎ¬Ï„Ï‰ control bar */
  left:50%;
  transform:translateX(-50%);
  background:rgba(0,0,0,.70);
  border:1px solid rgba(255,255,255,.25);
  border-radius:8px;
  padding:6px 8px;
  display:flex;
  flex-direction:column;
  gap:6px;
  z-index:2000;
  color:#fff;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  font-size:12px;
}
.drive-controls .dc-row{ display:flex; align-items:center; gap:8px; }
.drive-controls .dc-lbl{ width:14px; font-weight:800; }
.drive-controls .dc-val{
  width:74px;
  text-align:right;
  opacity:.9;
  font-variant-numeric: tabular-nums;
}
.drive-controls input[type="range"]{ width:150px; }

/* ÎºÏÏÎ²ÎµÏ„Î±Î¹ ÏƒÏ„Î¿ intro veil ÏŒÏ€Ï‰Ï‚ Ï„Î± Î¬Î»Î»Î± UI */
body.intro-open #driveCtrl{ visibility:hidden !important; }


    /* === Measurement HUD + Aâ€“f plot (DEV overlay) === */
    #measureHUD{
      position:absolute;
      right:16px;
      top:16px;
      z-index:9999;
      width:280px;
      padding:10px 12px;
      background:rgba(0,0,0,0.55);
      border:1px solid rgba(255,255,255,0.18);
      border-radius:10px;
      color:#fff;
      font: 13px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      pointer-events:none;
    }
    #measureHUD .mh-row{display:flex; align-items:center; justify-content:space-between; margin-bottom:6px;}
    #measureHUD .mh-title{font-weight:700; letter-spacing:.2px;}
    #measureHUD .mh-chip{
      font-size:12px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.25);
      background:rgba(255,255,255,0.08);
    }
    #measureHUD .mh-grid{display:grid; grid-template-columns: 52px 1fr; gap:4px 10px;}
    #measureHUD .mh-k{opacity:.85;}
    #measureHUD .mh-v{font-variant-numeric: tabular-nums; text-align:right;}
    #measureHUD .mh-note{margin-top:8px; opacity:.85; font-size:12px;}

    #afCanvas{
      position:absolute;
      left:16px;
      bottom:16px;
      z-index:9998;
      border-radius:10px;
      background:rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.18);
      pointer-events:none;
    }


    #xtMiniCanvas{
      position:absolute;
      left:50%;
      top:22px;
      transform:translateX(-50%);
      z-index:9997;
      border-radius:14px;
      background:rgba(0,0,0,0.40);
      border:1px solid rgba(255,255,255,0.18);
      box-shadow: 0 12px 30px rgba(0,0,0,0.28);
      pointer-events:none;
      display:none;
    }

  
  /* Disable mini x(t) widget near navigation (not used) */
  #btnXTmini, #xtMiniCanvas{ display:none !important; }

/* Marble track styling (b-dependent) */
#marbleTrack{ background: #e9e9e9; transition: width 900ms ease, left 900ms ease, background 300ms linear; }
#marbleTrack.marble-b6{ background:#2E7D32; }
#marbleTrack.marble-b12{ background:#1565C0; }
#marbleTrack.marble-b24{ background:#6A1B9A; }
#marbleTrack.marble-bOther{ background:#455A64; }
</style>

</head>
<body class="intro-open">

  <div class="strobe-curtain" id="strobeCurtain" aria-hidden="true"></div>

<div class="stage" id="stage">
  <!-- ÎšÎ¿Ï…Î¼Ï€Î¹Î¬ Î³Î»ÏÏƒÏƒÎ±Ï‚ -->
  <div class="lang-toggle">
    <button id="btnLangGR" class="lang-btn active">GR</button>
    <button id="btnLangEN" class="lang-btn">EN</button>
  </div>

  <div class="curtain-top"></div>
  <div class="curtain-upper"></div>
  <div class="curtain-side left"></div>
  <div class="curtain-side right"></div>

  <div class="spotlight" id="spotlight"></div>

  <!-- Î¤Î±Î¼Ï€Î­Î»Î± Ï„Î¯Ï„Î»Î¿Ï… (default ÎºÎµÎ¯Î¼ÎµÎ½Î± â€“ Î¸Î± Î±Î½Ï„Î¹ÎºÎ±Ï„Î±ÏƒÏ„Î±Î¸Î¿ÏÎ½ Î±Ï€ÏŒ JSON.ui) -->
  <div class="signboard">
    <h1 id="signTitle">Î ÏÎ¬Î¾Î· 1Î·: Î— ÎšÎ¹Î½Î·Î¼Î±Ï„Î¹ÎºÎ® ÏƒÏ„Î± ... Î‘Î»Î³ÎµÎ²ÏÎ¹ÎºÎ¬</h1>
    <div class="sb-lineA" id="signLineA">Î ÏÏ‰Ï„Î±Î³Ï‰Î½Î¹ÏƒÏ„ÎµÎ¯ Î¿ Ï„Î±Î»Î±Î½Ï„Ï‰Ï„Î®Ï‚ (mâ‚, Dâ‚) ÎºÎ±Î¹ Î¿Î¹ Î¸ÎµÎ±Ï€Î¿Î¹Î¿Î¯(*)</div>
    <div class="sb-lineB" id="signLineB">ÏƒÏ„Î¿Î½ Î¼Î¿Î½ÏŒÎ»Î¿Î³Î¿ <span class="hl">Â«Î±Ï„Î­Î»ÎµÎ¹Ï‰Ï„Î¿ Ï€Î®Î³Î±Î¹Î½Îµ Î­Î»Î±Â»</span>... ÎµÏ€Î¯ ÏƒÎºÎ·Î½Î®Ï‚!</div>
    <div class="sb-lineC" id="signLineC">Î Î±ÏÎ±Î³Ï‰Î³Î®-Î£ÎºÎ·Î½Î¿Î¸ÎµÏƒÎ¯Î±: Î•Î¼Î·Ï‡. Î•Î½ÎµÏÎ³ÎµÎ¹Î¿ÏÎ»Î·Ï‚</div>
    <div class="sb-lineD" id="signLineD">(*) ... ÎµÏƒÎµÎ¯Ï‚</div>
  </div>

  <canvas id="xtMiniCanvas" width="720" height="190" aria-hidden="true"></canvas>

  <!-- 1. Î§ÏÎ¿Î½Î¿Î¼ÎµÏ„ÏÎ·Ï„Î®Ï‚ -->
  <div class="clock" id="clock">t = 0.00 s<span class="hint" id="slowHint"></span></div>

  <!-- 2. Î Î¯Î½Î±ÎºÎ±Ï‚ Î¼ÎµÏ„ÏÎ®ÏƒÎµÏ‰Î½ tâ€“x -->
  <div class="measure-box" id="measureBox">
    <div class="mb-title" id="measureTitle">ÎœÎµÏ„ÏÎ®ÏƒÎµÎ¹Ï‚</div>
    <table>
      <thead>
        <tr><th id="measureColIdx">Î±/Î±</th><th>t (s)</th><th>x (m)</th></tr>
      </thead>
      <tbody id="measureTBody"></tbody>
    </table>
  </div>

  <!-- 3. Î“ÏÎ¬Ï†Î·Î¼Î± xâ€“t -->
  <div id="xtChart"></div>

  <!-- 4. Î“ÏÎ¬Ï†Î·Î¼Î± xâ€“sin(Ï‰t) -->
  <div id="xSinChart"></div>

  <!-- 5. Î Î¯Î½Î±ÎºÎ±Ï‚ A, Ï‰, Ï†â‚€ -->
  <div class="params-box" id="paramsBox">
    <div id="paramA"></div>
    <div id="paramW"></div>
    <div id="paramPhi"></div>
  </div>

  <div class="laws" id="laws">
    <h4 id="lawsTitle">ÎÏŒÎ¼Î¿Î¹ Î‘.Î‘.Î¤.</h4>
    <div id="lawsBody" class="laws-body"></div>
  </div>
  <div id="lawCharts" class="law-charts"></div>

  <div class="ruler" id="ruler"></div>

  <!-- ÎºÎ±Î½Î¿Î½Î¹ÎºÏŒÏ‚ Î´ÎµÎ¯ÎºÏ„Î·Ï‚ -->
  <div class="marker" id="marker">
    <div class="marker-line"></div>
    <div class="marker-tip"></div>
  </div>
  <!-- ghost Î´ÎµÎ¯ÎºÏ„Î·Ï‚ -->
  <div class="marker" id="markerGhost">
    <div class="marker-line"></div>
    <div class="marker-tip"></div>
  </div>

  <!-- Î”Î¹ÎµÎ³Î­ÏÏ„Î·Ï‚ (Scotch yoke) â€” Î½Î­Î± assets (Phase 1) -->
  <div class="driver-mech" id="driverMech" aria-hidden="true">
    <img id="drvTable"  class="drv-table"  src="assets/table.png"  alt="table">
    <img id="drvWheel"  class="drv-wheel"  src="assets/troxos.png" alt="crank wheel">
    <img id="drvSlider" class="drv-slider" src="assets/slider.png" alt="slider">
    <img id="drvPin"    class="drv-pin"    src="assets/peiros.png" alt="pin">
  </div>

  <img id="spring" class="spring" src="spring.png" alt="ÎµÎ»Î±Ï„Î®ÏÎ¹Î¿">
  <div class="actor" id="actor"><img src="skater.png" alt="Skater"></div>
  <div class="marble-track" id="marbleTrack" aria-hidden="true"></div>
  <div class="marble-track ghost" id="marbleTrackGhost" aria-hidden="true"></div>
  <div class="floor"></div>

  <img class="audience-extra" id="audienceExtra" src="koino_extra.png" alt="Î­Î¾Ï„ÏÎ± ÎºÎ¿Î¹Î½ÏŒ">
  <img class="audience-main" src="koino.png" alt="ÎºÎ¿Î¹Î½ÏŒ">

  <div class="viewers" id="viewersStrip">
    <div class="viewer-avatar" data-idx="0"></div>
    <div class="viewer-avatar" data-idx="1"></div>
    <div class="viewer-avatar" data-idx="2"></div>
    <div class="viewer-avatar" data-idx="3"></div>
    <div class="viewer-avatar" data-idx="4"></div>
  </div>

  <!-- ÎœÎ¬ÏƒÎºÎ± ÎµÎ¾ÏŒÎ´Î¿Ï… (ÎºÏÏÎ²ÎµÎ¹ Î¿Î¼Î¹Î»Î·Ï„Î­Ï‚ ÏŒÏ„Î±Î½ â€œÎ²Î³Î±Î¯Î½Î¿Ï…Î½â€ Î´ÎµÎ¾Î¹Î¬ Î±Ï€ÏŒ Ï„Î·Î½ ÎºÎµÎ½Ï„ÏÎ¹ÎºÎ® ÏƒÎºÎ·Î½Î®) -->
  <div class="exit-panel-mask" id="exitMask" aria-hidden="true"></div>
  <div class="exit-panel-mask left" id="exitMaskLeft" aria-hidden="true"></div>

  <div class="thought-bubble" id="bubble0">
    <div class="text"></div>
    <div class="checkmark">âœ“</div>
  </div>
  <div class="act-bubble" id="actBubble">Î˜Î•Î‘Î¤Î—Î£</div>

  <div class="controls" id="controls">
    <button id="btnNav"   title="Î¼ÎµÏ„Î±Î²Î¬ÏƒÎµÎ¹Ï‚">â˜°</button>
    <button id="btnPause" title="Ï€Î±ÏÏƒÎ·">â¸</button>
    <button id="btnPlay"  title="ÎºÎ±Î½Î¿Î½Î¹ÎºÎ¬">â–¶</button>
    <button id="btnReset" title="reset">â†º</button>
    <button id="btnNext"  title="ÎµÏ€ÏŒÎ¼ÎµÎ½Î¿">â­</button>
    <button id="btnBook"  title="Î”Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î¿ Î¼ÎµÏ„Î¬ Ï„Î¿ Ï„Î­Î»Î¿Ï‚ Ï„Î·Ï‚ Î ÏÎ¬Î¾Î·Ï‚ 1" disabled>ğŸ“–</button>
    <button id="btnXTOverlay" title="xâ€“t overlay">ğŸ“‰</button>
    <button id="btnXTmini" title="xâ€“t">ğŸ“‰</button>
  </div>

  <div class="drive-controls" id="driveCtrl" aria-label="ÏÏ…Î¸Î¼Î¯ÏƒÎµÎ¹Ï‚ Î´Î¹ÎµÎ³Î­ÏÏ„Î·">
    <div class="dc-row">
      <span class="dc-lbl">f</span>
      <select id="driveRatio" aria-label="ÏƒÏ…Ï‡Î½ÏŒÏ„Î·Ï„Î± Î´Î¹ÎµÎ³Î­ÏÏ„Î· Ï‰Ï‚ Ï€Î¿Î»Î»Î±Ï€Î»Î¬ÏƒÎ¹Î¿ Ï„Î·Ï‚ Î¹Î´Î¹Î¿ÏƒÏ…Ï‡Î½ÏŒÏ„Î·Ï„Î±Ï‚">
        
        <option value="0.00">OFF</option>
<option value="0.60">0.60 fâ‚€</option>
        <option value="0.75">0.75 fâ‚€</option>
        <option value="0.90">0.90 fâ‚€</option>
        <option value="1.00">1.00 fâ‚€</option>
        <option value="1.10">1.10 fâ‚€</option>
        <option value="1.20">1.20 fâ‚€</option>
        <option value="1.50">1.50 fâ‚€</option>
      </select>
      <span class="dc-val" id="driveFreqVal">OFF Â· â€“ Hz</span>
    </div>
    <div class="dc-row">
      <span class="dc-lbl">b</span>
      <select id="driveB">
  <option value="0">0</option>
  <option value="6">6</option>
  <option value="12">12</option>
  <option value="24">24</option>
  <option value="30">30</option>
</select>
      <span class="dc-val" id="driveBVal">0 kg/s</span>
    </div>
  </div>

</div>

<div class="startbreak" id="startBreak">
    <div class="box">
      <h3 id="startBreakTitle">ÎˆÎ½Î±ÏÎ¾Î· Î Î±ÏÎ¬ÏƒÏ„Î±ÏƒÎ·Ï‚</h3>
      <p  id="startBreakMsg">Î•Î½Î±Ï‚ Î¸ÎµÎ±Ï„Î®Ï‚ Î±Ï‚ ÎºÎ¬Î½ÎµÎ¹ ÎºÎ»Î¹Îº ÏƒÏ„Î·Î½ ÎˆÎ½Î±ÏÎ¾Î·</p>
      <button class="start-btn" id="startBtn">ÎˆÎ½Î±ÏÎ¾Î·</button>
    </div>
  </div>

  <div class="countdown-overlay" id="countdownOverlay">
    <div class="countdown-box">
      <div class="countdown-main" id="countdownMain">Î— Ï€Î±ÏÎ¬ÏƒÏ„Î±ÏƒÎ· Î±ÏÏ‡Î¯Î¶ÎµÎ¹.</div>
      <div class="countdown-sub"  id="countdownSub">ÏÏÎ± Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï‡Î±ÏÏ„Î¯ ÎºÎ±Î¹ Î¼Î¿Î»ÏÎ²Î¹!</div>
      <div class="countdown-timer" id="countdownTimer">5</div>
    </div>
  </div>

  <div class="actbreak" id="actBreak">
    <div class="box">
      <h3 id="actBreakTitle">Î¤Î­Î»Î¿Ï‚ Î ÏÎ¬Î¾Î·Ï‚ 1</h3>
      <p  id="actBreakMsg">ÎŸ (mâ‚,Dâ‚) ÏƒÏ…Î½ÎµÏ‡Î¯Î¶ÎµÎ¹. Î•Î¯ÏƒÏ„Îµ Î­Ï„Î¿Î¹Î¼Î¿Î¹ Î³Î¹Î± Ï„Î· Î”ÎµÏÏ„ÎµÏÎ· Î ÏÎ¬Î¾Î·;</p>
      <button id="btnAct2">ÎˆÎ½Î±ÏÎ¾Î· Î ÏÎ¬Î¾Î·Ï‚ 2</button>
    </div>
  </div>

  <div class="foyerbreak" id="foyerBreak">
    <div class="box">
      <h3 id="foyerBreakTitle">Î¤Î­Î»Î¿Ï‚ Î ÏÎ¬Î¾Î·Ï‚ 2</h3>
      <p  id="foyerBreakMsg">Î•Î»ÎµÏÎ¸ÎµÏÎ· ÏƒÏ…Î¶Î®Ï„Î·ÏƒÎ· ÏƒÏ„Î¿ Ï‡ÏÏÎ¿ Ï„Î¿Ï… Ï†Î¿Ï…Î±Î³Î¹Î­!</p>
      <button id="btnFoyerGo">ÎœÎµÏ„Î¬Î²Î±ÏƒÎ· ÏƒÏ„Î¿ Î¦Î¿Ï…Î±Î³Î¹Î­</button>
    </div>
  </div>
  
  <div class="actbreak" id="navBreak">
    <div class="box">
      <h3 id="navTitle">Î“ÏÎ®Î³Î¿ÏÎ· ÎœÎµÏ„Î¬Î²Î±ÏƒÎ·</h3>
      <p id="navMsg">Î£Ï…Î½Ï„Î¿Î¼ÎµÏÏƒÎµÎ¹Ï‚ Î³Î¹Î± ÎµÏ€Î±Î½Î¬Î»Î·ÏˆÎ·/Î­Î»ÎµÎ³Ï‡Î¿. Î¤Î¿ Â«Î’Î¹Î²Î»Î¯Î¿ Î Î±ÏÎ¬ÏƒÏ„Î±ÏƒÎ·Ï‚Â» Î¾ÎµÎºÎ»ÎµÎ¹Î´ÏÎ½ÎµÎ¹ Î¼ÏŒÎ½Î¿ Î¼ÎµÏ„Î¬ Ï„Î¿ Ï„Î­Î»Î¿Ï‚ Ï„Î·Ï‚ Î ÏÎ¬Î¾Î·Ï‚ 1.</p>
      <div class="navgrid">
        <button id="navToAct1">Î ÏÎ¬Î¾Î· 1</button>
        <button id="navToAct2">Î ÏÎ¬Î¾Î· 2</button>
        <button id="navToFoyer">Î¦Î¿Ï…Î±Î³Î¹Î­</button>
      </div>
      <button id="navClose">ÎšÎ»ÎµÎ¯ÏƒÎ¹Î¼Î¿</button>
    </div>
  </div>

  <div class="actbreak" id="act3Break" style="display:none;">
    <div class="box">
      <h3 id="act3BreakTitle">Î ÏÎ¬Î¾Î· 3Î·</h3>
      <p  id="act3BreakMsg">ÎŸ (mâ‚,Dâ‚) ÏƒÏ…Î½ÎµÏ‡Î¯Î¶ÎµÎ¹. Î•Î¯ÏƒÏ„Îµ Î­Ï„Î¿Î¹Î¼Î¿Î¹ Î³Î¹Î± Ï„Î·Î½ Î¤ÏÎ¯Ï„Î· Î ÏÎ¬Î¾Î·;</p>
      <button id="btnAct3" disabled aria-disabled="true" title="Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Ï€ÏÎ¿Ï†Î±Î½ÏÏ‚ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î·!">ÎˆÎ½Î±ÏÎ¾Î· Î ÏÎ¬Î¾Î·Ï‚ 3</button>
    </div>
  </div>

  <div class="foyer" id="foyer">
    <div class="wrap">
      <div class="foyer-titlebar" id="foyerTitlebar">
        <div class="ft-line1" id="foyerTitle1"></div>
        <div class="ft-line2" id="foyerTitle2"></div>
      </div>

      <!-- Teaser ÎµÏ„Î¹ÎºÎ­Ï„Î± (Î±Î´ÏÎ±Î½Î®Ï‚) Î³Î¹Î± Ï„Î·Î½ Î ÏÎ¬Î¾Î· 3 -->
      <div class="act3-teaser" id="act3Teaser" aria-hidden="true">Î ÏÎ¬Î¾Î· 3Î· (ÏƒÏÎ½Ï„Î¿Î¼Î±)</div>

      <!-- ÎˆÎ½Î´ÎµÎ¹Î¾Î· â€œÏ€Î¿Î¹Î¿Ï‚ Î¼Î¹Î»Î¬ÎµÎ¹â€ ÏƒÏ„Î¿ Ï†Î¿Ï…Î±Î³Î¹Î­ (Î¯Î´Î¹Î¿ ÏƒÏ„Ï…Î» Î¼Îµ Ï„Î¿ Î’Î¹Î²Î»Î¯Î¿) -->
      <div class="foyer-speaker-indicator" id="foyerSpeakerBadge" aria-hidden="true">
        <span class="speaker-badge">
          <span class="speaker-avatar" id="foyerSpeakerAvatar"></span>
          <span class="speaker-name" id="foyerSpeakerName">Î˜ÎµÎ±Ï„Î®Ï‚</span>
        </span>
      </div>
      <div class="board-left"  id="boardLeft"></div>
      <div class="board-right" id="boardRight"></div>
    </div>
  </div>

  <div class="foyer-bubble" id="foyerBubble">Î˜Î•Î‘Î¤Î—Î£</div>
</div>


<!-- Intro (Ï€Î­Ï€Î»Î¿ Ï€Î¬Î½Ï‰ Î±Ï€ÏŒ Ï„Î· ÏƒÎºÎ·Î½Î®) -->
<div id="introOverlay" class="intro-veil" aria-hidden="false">
  <div class="intro-card" role="dialog" aria-modal="true" aria-label="Î ÏÏŒÎ³ÏÎ±Î¼Î¼Î± Ï€Î±ÏÎ¬ÏƒÏ„Î±ÏƒÎ·Ï‚">
    <img id="introPoster" class="intro-poster" src="" alt="">
    <div id="introLeaflet" class="intro-leaflet"></div>
    <div id="introLangSwitch" class="intro-lang" aria-label="Language">
      <button type="button" class="intro-lang-btn" data-lang="gr">Î•Î»Î»Î·Î½Î¹ÎºÎ¬</button>
      <button type="button" class="intro-lang-btn" data-lang="en">English</button>
    </div>
    <button id="introContinue" class="intro-continue">Î£Ï…Î½Î­Ï‡ÎµÎ¹Î±</button>
  </div>
</div>

<script>
/* ---------- Î”Î•Î”ÎŸÎœÎ•ÎÎ‘ Î‘Î ÎŸ dialogs-*.json ---------- */

let VIEWERS = [];
let ACT1    = [];
let ACT2    = [];
let ACT3    = [];
let FOYER   = [];

let foyerTBody = null;

/* UI ÎºÎµÎ¯Î¼ÎµÎ½Î± Î±Ï€ÏŒ JSON.ui */
let UI = {};
let UI_TITLES = null;

let currentLang = (()=>{
  try{
    const p = new URLSearchParams(location.search);
    const q = (p.get('lang') || '').toLowerCase();
    if(q === 'en' || q === 'gr') return q;
  }catch(_e){}
  try{
    const saved = (localStorage.getItem('aatLang') || '').toLowerCase();
    if(saved === 'en' || saved === 'gr') return saved;
  }catch(_e){}
  return 'gr';
})();  // 'gr' Î® 'en'
let btnLangGR = null;
let btnLangEN = null;

/* ÎšÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ· Ï€Î±ÏÎ¬ÏƒÏ„Î±ÏƒÎ·Ï‚ Î³Î¹Î± locks ÎºÎ¿Ï…Î¼Ï€Î¹ÏÎ½ */
let phase = 'idle'; // idle, countdown, act1, act2, between2andFoyer, foyer

/* ---------- INTRO (ÎµÎ½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½Î¿) ---------- */

let INTRO = null;

const introOverlay  = document.getElementById('introOverlay');
const introPoster   = document.getElementById('introPoster');
const introLeaflet  = document.getElementById('introLeaflet');
const introContinue = document.getElementById('introContinue');

function _introEsc(s){
  // Î•Ï€Î¹Î»Î¿Î³Î® Î‘: ÎµÏ€Î¹Ï„ÏÎ­Ï€Î¿Ï…Î¼Îµ raw HTML ÏƒÏ„Î¿ intro.json (ÏŒÏ€Ï‰Ï‚ ÏƒÏ„Î¿Ï…Ï‚ Î´Î¹Î±Î»ÏŒÎ³Î¿Ï…Ï‚).
  return String(s ?? '');
}

function _introFlushPara(out, paraLines){
  if(!paraLines.length) return;
  const html = paraLines.map(_introEsc).join('<br>');
  out.push(`<p>${html}</p>`);
  paraLines.length = 0;
}

function _introAppendToLastLi(out, extraLine){
  if(!out.length) return false;
  const last = out[out.length-1];
  if(!last.endsWith('</li>')) return false;
  out[out.length-1] = last.slice(0,-5) + '<br>' + _introEsc(extraLine) + '</li>';
  return true;
}

function introLeafletTextToHTML(text){
  const raw = String(text ?? '').replace(/\r\n/g,'\n');
  const lines = raw.split('\n');

  const out = [];
  const para = [];

  let inUl = false;
  let inSub = false;
  let pending = null; // 'ul' | 'sub' | null

  const closeSub = ()=>{
    if(inSub){ out.push('</ul>'); inSub=false; }
  };
  const closeUl = ()=>{
    closeSub();
    if(inUl){ out.push('</ul>'); inUl=false; }
  };

  for(let i=0;i<lines.length;i++){
    const line = lines[i];
    const t = line.trim();

    if(t === ''){
      if(pending){ pending=null; }
      _introFlushPara(out, para);
      closeUl();
      continue;
    }

    if(t === 'â€¢' || t === 'ï‚·'){
      _introFlushPara(out, para);
      if(!inUl){ out.push('<ul class="leaflet-ul">'); inUl=true; }
      pending = 'ul';
      continue;
    }

    if(t === 'o' || t === 'Î¿' || t === 'â—¦'){
      _introFlushPara(out, para);
      if(!inUl){ out.push('<ul class="leaflet-ul">'); inUl=true; }
      if(!inSub){ out.push('<ul class="leaflet-sub">'); inSub=true; }
      pending = 'sub';
      continue;
    }

    if(pending === 'sub'){
      out.push(`<li>${_introEsc(line)}</li>`);
      pending = null;
      continue;
    }
    if(pending === 'ul'){
      out.push(`<li>${_introEsc(line)}</li>`);
      pending = null;
      continue;
    }

    // Î±Î½ ÎµÎ¯Î¼Î±ÏƒÏ„Îµ ÏƒÎµ Î»Î¯ÏƒÏ„Î±, Î¸ÎµÏ‰ÏÎµÎ¯Ï„Î±Î¹ ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î± Ï„Î¿Ï… Ï€ÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î¿Ï… li
    if(inUl){
      if(!_introAppendToLastLi(out, line)){
        out.push(`<li>${_introEsc(line)}</li>`);
      }
      continue;
    }

    // Î±Î»Î»Î¹ÏÏ‚ ÎµÎ¯Î½Î±Î¹ Ï€Î±ÏÎ¬Î³ÏÎ±Ï†Î¿Ï‚
    para.push(line);
  }

  _introFlushPara(out, para);
  closeUl();

  return out.join('\n');
}

function closeIntro(){
  introOverlay.classList.add('hidden');
  document.body.classList.remove('intro-open');
}

async function initIntro(){
  let res;
  try{
    const introFile = (currentLang === 'en') ? 'intro-en.json' : 'intro.json';
    res = await fetch(introFile, { cache: 'no-store' });
    if(!res.ok && introFile !== 'intro.json'){
      res = await fetch('intro.json', { cache: 'no-store' });
    }
    if(!res.ok) throw new Error('intro.json load failed');
    INTRO = await res.json();
  }catch(e){
    // Î±Î½ Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ intro.json, Î±Ï€Î»Î¬ Î´ÎµÎ½ Î´ÎµÎ¯Ï‡Î½Î¿Ï…Î¼Îµ intro
    introOverlay.classList.add('hidden');
    document.body.classList.remove('intro-open');
    return;
  }

    // Î‘Î½ Î®ÏÎ¸Î±Î¼Îµ Î±Ï€ÏŒ â€œÎ³ÏÎ®Î³Î¿ÏÎ· Î¼ÎµÏ„Î¬Î²Î±ÏƒÎ·â€ (nav=1), Ï€Î±ÏÎ±ÎºÎ¬Î¼Ï€Ï„Î¿Ï…Î¼Îµ Ï„Î¿ intro.
  try{
    const u = new URL(window.location.href);
    const startQ = u.searchParams.get('start');
    const navQ   = u.searchParams.get('nav');
    if(startQ && navQ === '1'){
      introOverlay.classList.add('hidden');
      document.body.classList.remove('intro-open');
      return;
    }
  }catch(_e){}

if(!INTRO || INTRO.enabled === false){
    introOverlay.classList.add('hidden');
    document.body.classList.remove('intro-open');
    return;
  }

  document.body.classList.add('intro-open');

  const _introSrcPick = (currentLang==='en' && INTRO.posterSrcEn) ? INTRO.posterSrcEn
                    : (currentLang==='gr' && INTRO.posterSrcGr) ? INTRO.posterSrcGr
                    : (INTRO.posterSrc || '');
const _introSrcRaw = String(_introSrcPick || ((currentLang==='en') ? 'assets/theatron-banner-en.png' : 'assets/theatron-banner.png') || '').trim();
  if(_introSrcRaw){
    const _safe = _introSrcRaw.replace(/^\/+/, '');          // ÎºÏŒÏˆÎµ leading "/" (GitHub Pages /repo Î¸Î­Î¼Î±)
    const _resolved = new URL(_safe, res.url).href;          // resolve relative to intro.json
    introPoster.src = _resolved;
    introOverlay.style.setProperty('--intro-bg', `url("${_resolved}")`);
  }else{
    introPoster.src = '';
    introOverlay.style.removeProperty('--intro-bg');
  }
  const _altPick = (currentLang==='en' && INTRO.posterAltEn) ? INTRO.posterAltEn
              : (currentLang==='gr' && INTRO.posterAltGr) ? INTRO.posterAltGr
              : (INTRO.posterAlt || '');
introPoster.alt = _altPick;

  introLeaflet.innerHTML = introLeafletTextToHTML(INTRO.leafletText || '');

  const introCardEl = introOverlay ? introOverlay.querySelector('.intro-card') : null;
  if(introCardEl){
    introCardEl.setAttribute('aria-label', INTRO.ariaLabel || (currentLang==='en' ? 'Show program' : 'Î ÏÏŒÎ³ÏÎ±Î¼Î¼Î± Ï€Î±ÏÎ¬ÏƒÏ„Î±ÏƒÎ·Ï‚'));
  }

  introContinue.textContent = INTRO.buttonLabel || (currentLang==='en' ? 'Continue' : 'Î£Ï…Î½Î­Ï‡ÎµÎ¹Î±');

  // Language switch inside intro overlay (no need for URL params by the user)
  const introLangSwitch = document.getElementById('introLangSwitch');
  if(introLangSwitch){
    const btns = introLangSwitch.querySelectorAll('button[data-lang]');
    btns.forEach(b=>{
      const L = String(b.getAttribute('data-lang')||'').toLowerCase();
      b.classList.toggle('active', L===currentLang);
      b.onclick = ()=>{
        const chosen = L==='en' ? 'en' : 'gr';
        try{ localStorage.setItem('aatLang', chosen); }catch(_e){}
        const u = new URL(window.location.href);
        u.searchParams.set('lang', chosen);
        window.location.href = u.toString();
      };
    });
  }

  introContinue.onclick = closeIntro;
}

// Ï„ÏÎ­Ï‡ÎµÎ¹ Î±Î¼Î­ÏƒÏ‰Ï‚ (Î· ÏƒÎºÎ·Î½Î® Î±Ï€ÏŒ ÎºÎ¬Ï„Ï‰ Ï†Î¿ÏÏ„ÏÎ½ÎµÎ¹ ÎºÎ±Î½Î¿Î½Î¹ÎºÎ¬)
initIntro();

/* ---------- Î¦Ï…ÏƒÎ¹ÎºÎ® / ÏƒÎºÎ·Î½Î® ---------- */

const stage        = document.getElementById('stage');
const springEl     = document.getElementById('spring');
const actor        = document.getElementById('actor');
const driverMech   = document.getElementById('driverMech');
const drvTable     = document.getElementById('drvTable');
const drvWheel     = document.getElementById('drvWheel');
const drvSlider    = document.getElementById('drvSlider');
const drvPin       = document.getElementById('drvPin');

const spotlight    = document.getElementById('spotlight');
const rulerEl      = document.getElementById('ruler');
let rulerZeroX = 0; // px (stage coords): Ï„Î¿ 0 Ï„Î·Ï‚ Î¼ÎµÏ„ÏÎ¿Ï„Î±Î¹Î½Î¯Î±Ï‚ (Î¼Î­ÏƒÎ± ÏƒÏ„Î· ÏƒÎºÎ·Î½Î®)
const markerEl     = document.getElementById('marker');
const markerGhostEl= document.getElementById('markerGhost');
markerGhostEl.style.zIndex = '159';

const clockEl      = document.getElementById('clock');
const slowHint     = document.getElementById('slowHint');
const measureBox   = document.getElementById('measureBox');
const measureTBody = document.getElementById('measureTBody');
const paramsBoxEl  = document.getElementById('paramsBox');
const paramAEl     = document.getElementById('paramA');
const paramWEl     = document.getElementById('paramW');
const paramPhiEl   = document.getElementById('paramPhi');
const lawsPane     = document.getElementById('laws');
const lawsBody     = document.getElementById('lawsBody');
const lawCharts    = document.getElementById('lawCharts');
const xtChartEl    = document.getElementById('xtChart');
const xSinChartEl  = document.getElementById('xSinChart');
const audienceExtra= document.getElementById('audienceExtra');
const audienceMain = document.querySelector('.audience-main');

const bubbleEl     = document.getElementById('bubble0');
const bubbleTextEl = bubbleEl.querySelector('.text');
const actBubble    = document.getElementById('actBubble');

const startBtn          = document.getElementById('startBtn');
const startBreak        = document.getElementById('startBreak');
const startBreakTitle   = document.getElementById('startBreakTitle');
const startBreakMsg     = document.getElementById('startBreakMsg');

const countdownOverlay  = document.getElementById('countdownOverlay');
const countdownTimerEl  = document.getElementById('countdownTimer');

const btnPause   = document.getElementById('btnPause');
const btnPlay    = document.getElementById('btnPlay');
const btnReset   = document.getElementById('btnReset');
  const btnNext    = document.getElementById('btnNext');
  const btnNav     = document.getElementById('btnNav');
  const navBreak   = document.getElementById('navBreak');
  const navClose   = document.getElementById('navClose');
  const navToAct1  = document.getElementById('navToAct1');
  const navToAct2  = document.getElementById('navToAct2');
  const navToFoyer = document.getElementById('navToFoyer');
const btnBook    = document.getElementById('btnBook');


const btnXTOverlay = document.getElementById('btnXTOverlay');
const ACT1_UNLOCK_KEY = 'aat_act1_completed';
// XT overlay toggle
if(btnXTOverlay){
  btnXTOverlay.onclick = ()=>{
    // Toggle ÎœÎŸÎÎŸ Ï„Î·Î½ Î¿ÏÎ±Ï„ÏŒÏ„Î·Ï„Î±. Î— ÎºÎ±Ï„Î±Î³ÏÎ±Ï†Î®/ÏÎ¿Î® ÏƒÏ…Î½ÎµÏ‡Î¯Î¶ÎµÎ¹ ÏŒÏ€Ï‰Ï‚ Î¿ Î¼ÎµÏ„ÏÎ·Ï„Î®Ï‚ Ï‡ÏÏŒÎ½Î¿Ï….
    ensureXTOverlay();
    const isShown = (!!xtOverlayCan && xtOverlayCan.style.display !== 'none');
    setXTOverlay(!isShown);
    btnXTOverlay.classList.toggle('active', !isShown);
  };
}
let bookUnlocked = (localStorage.getItem(ACT1_UNLOCK_KEY) === '1');

function setBookUnlocked(on, persist=true){
  bookUnlocked = !!on;

  // persistence: once unlocked, stays unlocked until user clears storage manually
  if(persist && bookUnlocked){
    try{ localStorage.setItem(ACT1_UNLOCK_KEY, '1'); }catch(e){}
  }

  if(!btnBook) return;

  btnBook.disabled = !bookUnlocked;
  btnBook.style.opacity = bookUnlocked ? '1' : '0.35';
  btnBook.style.filter  = bookUnlocked ? 'none' : 'grayscale(100%)';
  btnBook.title = bookUnlocked ? 'Î’Î¹Î²Î»Î¯Î¿ Î Î±ÏÎ¬ÏƒÏ„Î±ÏƒÎ·Ï‚' : 'Î”Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î¿ Î¼ÎµÏ„Î¬ Ï„Î¿ Ï„Î­Î»Î¿Ï‚ Ï„Î·Ï‚ Î ÏÎ¬Î¾Î·Ï‚ 1';
}

setBookUnlocked(bookUnlocked, false);

const actBreak   = document.getElementById('actBreak');
const btnAct2    = document.getElementById('btnAct2');
const foyerBreak = document.getElementById('foyerBreak');
const btnFoyerGo = document.getElementById('btnFoyerGo');

const act3Break = document.getElementById('act3Break');
const btnAct3   = document.getElementById('btnAct3');

const foyerEl     = document.getElementById('foyer');
const boardLeft   = document.getElementById('boardLeft');
const boardRight  = document.getElementById('boardRight');
const foyerTitle1 = document.getElementById('foyerTitle1');
const foyerTitle2 = document.getElementById('foyerTitle2');
const foyerBubble = document.getElementById('foyerBubble');
const foyerSpeakerBadge  = document.getElementById('foyerSpeakerBadge');
const foyerSpeakerAvatar = document.getElementById('foyerSpeakerAvatar');
const foyerSpeakerName   = document.getElementById('foyerSpeakerName');

const viewersStrip = document.getElementById('viewersStrip');

let t0 = performance.now();
let lastFrame = t0;
let playbackTime = 0;
let obsStarted = false;
let obsStartPlaybackOffset = 0;

let lastSampleObsTime = -Infinity;
let sampleInterval = 0.4;
let measureRowIdx = 0;

let mode = 'run';


/* ---------- PAUSE ENGINE (Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÏŒ pause ÏƒÎµ timers/typewriter/ÏÎ¿Î®) ---------- */

const TM = (() => {
  let _paused = false;
  let _nextId = 1;
  const _timers = new Map(); // id -> rec

  function _schedule(rec, delayMs){
    rec.start = performance.now();
    rec.remaining = delayMs;
    rec.nativeId = window.setTimeout(() => {
      // Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î­Ï‡ÎµÎ¹ ÎºÎ±Î¸Î±ÏÎ¹ÏƒÏ„ÎµÎ¯/Ï€Î±Î³ÏÏƒÎµÎ¹/Î¾Î±Î½Î±Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„ÎµÎ¯
      if(!_timers.has(rec.id)) return;
      _timers.delete(rec.id);
      try{ rec.cb(); }catch(e){ console.error(e); }
    }, Math.max(0, delayMs|0));
  }

  function setTimeout(cb, delayMs=0){
    const id = _nextId++;
    const rec = { id, cb, start: 0, remaining: (delayMs|0), nativeId: null };
    _timers.set(id, rec);

    if(_paused){
      // Î´ÎµÎ½ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¯Î¶Î¿Ï…Î¼Îµ Ï„ÏÏÎ±, ÎºÏÎ±Ï„Î¬Î¼Îµ Î¼ÏŒÎ½Î¿ remaining
      rec.start = performance.now();
      return id;
    }
    _schedule(rec, rec.remaining);
    return id;
  }

  function clearTimeout(id){
    const rec = _timers.get(id);
    if(!rec) return;
    _timers.delete(id);
    if(rec.nativeId != null) window.clearTimeout(rec.nativeId);
  }

  function pause(){
    if(_paused) return;
    _paused = true;
    const now = performance.now();
    for(const rec of _timers.values()){
      if(rec.nativeId != null){
        window.clearTimeout(rec.nativeId);
        rec.nativeId = null;
        const elapsed = now - rec.start;
        rec.remaining = Math.max(0, rec.remaining - elapsed);
      }else{
        // Î®Î´Î· Î¼Î· Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼Î­Î½Î¿
        rec.start = now;
      }
    }
  }

  function resume(){
    if(!_paused) return;
    _paused = false;
    for(const rec of _timers.values()){
      if(rec.nativeId == null){
        _schedule(rec, rec.remaining);
      }
    }
  }

  function clearAll(){
    for(const rec of _timers.values()){
      if(rec.nativeId != null) window.clearTimeout(rec.nativeId);
    }
    _timers.clear();
  }

  function sleep(ms){
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  function isPaused(){ return _paused; }

  return { setTimeout, clearTimeout, pause, resume, clearAll, sleep, isPaused };
})();

/* Countdown state (Î³Î¹Î± pause Ï€Î¿Ï… Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÎ¬ Ï€Î±Î³ÏÎ½ÎµÎ¹) */
const countdownState = { active:false, remainingMs:0, lastNow:0 };


let uXT = null;   // xâ€“t canvas
let vCan = null;  // vâ€“t
let aCan = null;  // aâ€“t
let axCan = null; // aâ€“x
let xsCan = null; // xâ€“sin(Ï‰t)

/* Î²Î¹Î²Î»Î¯Î¿ / export Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ */
let BOOK_SAMPLES = [];
const BOOK_STORAGE_KEY = 'aatBookData';

const m   = 70;
const T   = 6.0;
const A_m = 3.0;
const pxPerMeter = 50;
const RULER_CENTER_M = 10;
const omega = 2*Math.PI/T;
const A_px  = A_m*pxPerMeter;

/* ÏƒÏ…Î½Î¿Î»Î¹ÎºÏŒÏ‚ Ï‡ÏÏŒÎ½Î¿Ï‚ Î¬Î¾Î¿Î½Î± xâ€“t: 2T */
const XT_TOTAL_T = 2*T;

/* offset Î³Î¹Î± avatars ÏƒÏ„Î¹Ï‚ Ï€ÏÎ¬Î¾ÎµÎ¹Ï‚ Î±Ï€ÏŒ JSON. Î ÏÎ¿ÎµÏ€Î¹Î»Î¿Î³Î®: -60 */
let ACTS_AVATAR_OFFSET = -60;

let ghost       = null;
let ghostSpring = null;
let ghostActive = false;
let ghostVisibility = 0;

let springNaturalWidth  = null;
let springNaturalHeight = null;
let actorFloorBottomPx  = null;

let audienceLightsOn = true;

/* ---------- XT MARK (Î½Î­Î¿ t=0 + ÎºÎ±Î¼Ï€ÏÎ»Î·) ---------- */

let xtMarkState = {
  active: false,
  showTail: false
};

function computePhaseZeroT(phi0Rad, omegaVal){
  const twoPi = 2*Math.PI;
  if(!isFinite(phi0Rad) || !isFinite(omegaVal) || omegaVal === 0) return 0;

  let p = phi0Rad % twoPi;
  if(p < 0) p += twoPi;

  const tZero = (twoPi - p) / omegaVal;
  const TT = twoPi / omegaVal;
  if(Math.abs(tZero - TT) < 1e-9) return 0;
  return tZero;
}

// Ï†0 (ÏƒÎµ rad) Î³Î¹Î± Ï„Î· ÏƒÏ„Î¹Î³Î¼Î® t_obs=0, Î´Î·Î»Î±Î´Î® Ï†0 = Ï‰ * obsStartPlaybackOffset
function getPhi0Rad(){
  return omega * obsStartPlaybackOffset;
}

// Î’ÏÎ¯ÏƒÎºÎ¿Ï…Î¼Îµ Ï„Î· ÏƒÏ„Î¹Î³Î¼Î® t_zero ÏƒÏ„Î¿ [0,T] ÏŒÏ€Î¿Ï… Î· Ï†Î¬ÏƒÎ· Î¼Î·Î´ÎµÎ½Î¯Î¶ÎµÏ„Î±Î¹ Ï€ÏÏÏ„Î· Ï†Î¿ÏÎ¬ (mod 2Ï€)
// ÎºÎ±Î¹ Î¬ÏÎ± x=0 Î¼Îµ Î¸ÎµÏ„Î¹ÎºÎ® Ï†Î¿ÏÎ¬ (Î³Î¹Î± Ï„Î·Î½ ÎºÏŒÎºÎºÎ¹Î½Î· Ï€ÏÏŒÎ²Î»ÎµÏˆÎ·).
function xtZeroCrossingTime(){
  const phi0Rad = getPhi0Rad();
  return computePhaseZeroT(phi0Rad, omega);
}

function triggerXtZeroMark(ev){
  xtMarkState.active   = true;
  xtMarkState.showTail = !!(ev && ev.xtMarkTail);
}

/* ---------- UI Î±Ï€ÏŒ JSON.ui ---------- */

function applyUITextFromUI(){
  const ui = UI || {};

  const signTitle = document.getElementById('signTitle');
  const signLineA = document.getElementById('signLineA');
  const signLineB = document.getElementById('signLineB');
  const signLineC = document.getElementById('signLineC');
  const signLineD = document.getElementById('signLineD');
  const lawsTitle = document.getElementById('lawsTitle');
  const measureTitle = document.getElementById('measureTitle');
  const measureColIdx = document.getElementById('measureColIdx');
  const countdownMain = document.getElementById('countdownMain');
  const countdownSub  = document.getElementById('countdownSub');
  const actBreakTitle = document.getElementById('actBreakTitle');
  const actBreakMsg   = document.getElementById('actBreakMsg');
  const foyerBreakTitle = document.getElementById('foyerBreakTitle');
  const foyerBreakMsg   = document.getElementById('foyerBreakMsg');

  const hasTitles = UI_TITLES && (UI_TITLES.act1 || UI_TITLES.act2 || UI_TITLES.foyer);
  if(!hasTitles){
    if(signTitle   && ui.signTitle   != null) signTitle.textContent   = ui.signTitle;
    if(signLineA   && ui.signLineA   != null) signLineA.textContent   = ui.signLineA;
    if(signLineB   && ui.signLineB   != null) signLineB.innerHTML     = ui.signLineB;
    if(signLineC   && ui.signLineC   != null) signLineC.textContent   = ui.signLineC;
    if(signLineD   && ui.signLineD   != null) signLineD.textContent   = ui.signLineD;

  }
  if(lawsTitle   && ui.lawsTitle   != null) lawsTitle.textContent   = ui.lawsTitle;
  if(measureTitle&& ui.measureTitle!= null) measureTitle.textContent= ui.measureTitle;
  if(measureColIdx&&ui.measureColIdx!=null) measureColIdx.textContent= ui.measureColIdx;

  if(countdownMain && ui.countdownMain != null) countdownMain.textContent = ui.countdownMain;
  if(countdownSub  && ui.countdownSub  != null) countdownSub.textContent  = ui.countdownSub;

  if(actBreakTitle){
    const fb = (currentLang==='en') ? 'Act 2' : 'Î ÏÎ¬Î¾Î· 2Î·';
    actBreakTitle.textContent = (ui.actBreakTitle != null) ? ui.actBreakTitle : fb;
  }
  if(actBreakMsg){
    const fb = (currentLang==='en')
      ? 'The (mâ‚,Dâ‚) continues. Ready for Act 2?'
      : 'ÎŸ (mâ‚,Dâ‚) ÏƒÏ…Î½ÎµÏ‡Î¯Î¶ÎµÎ¹. Î•Î¯ÏƒÏ„Îµ Î­Ï„Î¿Î¹Î¼Î¿Î¹ Î³Î¹Î± Ï„Î· Î”ÎµÏÏ„ÎµÏÎ· Î ÏÎ¬Î¾Î·;';
    actBreakMsg.textContent = (ui.actBreakMsg != null) ? ui.actBreakMsg : fb;
  }
  if(btnAct2){
    const fb = (currentLang==='en') ? 'Start Act 2' : 'ÎˆÎ½Î±ÏÎ¾Î· Î ÏÎ¬Î¾Î·Ï‚ 2';
    btnAct2.textContent = (ui.btnAct2 != null) ? ui.btnAct2 : fb;
  }

  if(foyerBreakTitle){
    const fb = (currentLang==='en') ? 'Foyer' : 'Î¦Î¿Ï…Î±Î³Î¹Î­';
    foyerBreakTitle.textContent = (ui.foyerBreakTitle != null) ? ui.foyerBreakTitle : fb;
  }
  if(foyerBreakMsg){
    const fb = (currentLang==='en')
      ? 'Free discussion in the foyer!'
      : 'Î•Î»ÎµÏÎ¸ÎµÏÎ· ÏƒÏ…Î¶Î®Ï„Î·ÏƒÎ· ÏƒÏ„Î¿ Ï‡ÏÏÎ¿ Ï„Î¿Ï… Ï†Î¿Ï…Î±Î³Î¹Î­!';
    foyerBreakMsg.textContent = (ui.foyerBreakMsg != null) ? ui.foyerBreakMsg : fb;
  }
  if(btnFoyerGo){
    const fb = (currentLang==='en') ? 'Go to the Foyer' : 'ÎœÎµÏ„Î¬Î²Î±ÏƒÎ· ÏƒÏ„Î¿ Î¦Î¿Ï…Î±Î³Î¹Î­';
    btnFoyerGo.textContent = (ui.btnFoyerGo != null) ? ui.btnFoyerGo : fb;
  }

  // Quick Navigation overlay (Î“ÏÎ®Î³Î¿ÏÎ· ÎœÎµÏ„Î¬Î²Î±ÏƒÎ·)
  const navTitleEl  = document.getElementById('navTitle');
  const navMsgEl    = document.getElementById('navMsg');
  const navToAct1El = document.getElementById('navToAct1');
  const navToAct2El = document.getElementById('navToAct2');
  const navToFoyerEl= document.getElementById('navToFoyer');
  const navCloseEl  = document.getElementById('navClose');

  if(navTitleEl){
    const fb = (currentLang==='en') ? 'Quick Navigation' : 'Î“ÏÎ®Î³Î¿ÏÎ· ÎœÎµÏ„Î¬Î²Î±ÏƒÎ·';
    navTitleEl.textContent = (ui.navTitle != null) ? ui.navTitle : fb;
  }
  if(navMsgEl){
    const fb = (currentLang==='en')
      ? 'Shortcuts for repeat/check. The â€œPerformance Bookâ€ unlocks only after Act 1 ends.'
      : 'Î£Ï…Î½Ï„Î¿Î¼ÎµÏÏƒÎµÎ¹Ï‚ Î³Î¹Î± ÎµÏ€Î±Î½Î¬Î»Î·ÏˆÎ·/Î­Î»ÎµÎ³Ï‡Î¿. Î¤Î¿ Â«Î’Î¹Î²Î»Î¯Î¿ Î Î±ÏÎ¬ÏƒÏ„Î±ÏƒÎ·Ï‚Â» Î¾ÎµÎºÎ»ÎµÎ¹Î´ÏÎ½ÎµÎ¹ Î¼ÏŒÎ½Î¿ Î¼ÎµÏ„Î¬ Ï„Î¿ Ï„Î­Î»Î¿Ï‚ Ï„Î·Ï‚ Î ÏÎ¬Î¾Î·Ï‚ 1.';
    navMsgEl.textContent = (ui.navMsg != null) ? ui.navMsg : fb;
  }
  if(navToAct1El){
    const fb = (currentLang==='en') ? 'Act 1' : 'Î ÏÎ¬Î¾Î· 1';
    navToAct1El.textContent = (ui.navToAct1 != null) ? ui.navToAct1 : fb;
  }
  if(navToAct2El){
    const fb = (currentLang==='en') ? 'Act 2' : 'Î ÏÎ¬Î¾Î· 2';
    navToAct2El.textContent = (ui.navToAct2 != null) ? ui.navToAct2 : fb;
  }
  if(navToFoyerEl){
    const fb = (currentLang==='en') ? 'Foyer' : 'Î¦Î¿Ï…Î±Î³Î¹Î­';
    navToFoyerEl.textContent = (ui.navToFoyer != null) ? ui.navToFoyer : fb;
  }
  if(navCloseEl){
    const fb = (currentLang==='en') ? 'Close' : 'ÎšÎ»ÎµÎ¯ÏƒÎ¹Î¼Î¿';
    navCloseEl.textContent = (ui.navClose != null) ? ui.navClose : fb;
  }

  // Defaults for speaker/bubbles (placeholders)
  const foyerSpeakerNameEl = document.getElementById('foyerSpeakerName');
  if(foyerSpeakerNameEl){
    const fb = (currentLang==='en') ? 'Viewer' : 'Î˜ÎµÎ±Ï„Î®Ï‚';
    foyerSpeakerNameEl.textContent = (ui.foyerSpeakerName != null) ? ui.foyerSpeakerName : fb;
  }
  const actBubbleEl = document.getElementById('actBubble');
  if(actBubbleEl){
    const fb = (currentLang==='en') ? 'VIEWER' : 'Î˜Î•Î‘Î¤Î—Î£';
    actBubbleEl.textContent = (ui.actBubble != null) ? ui.actBubble : fb;
  }
  const foyerBubbleEl = document.getElementById('foyerBubble');
  if(foyerBubbleEl){
    const fb = (currentLang==='en') ? 'VIEWER' : 'Î˜Î•Î‘Î¤Î—Î£';
    foyerBubbleEl.textContent = (ui.foyerBubble != null) ? ui.foyerBubble : fb;
  }

  // Start overlay (before countdown)
  if(startBreakTitle){
    const fb = (currentLang==='en') ? 'Performance start' : 'ÎˆÎ½Î±ÏÎ¾Î· Î Î±ÏÎ¬ÏƒÏ„Î±ÏƒÎ·Ï‚';
    startBreakTitle.textContent = (ui.startBreakTitle != null) ? ui.startBreakTitle : fb;
  }
  if(startBreakMsg){
    // Keep it short and avoid repeating the same label twice.
    startBreakMsg.textContent = (currentLang==='en')
      ? 'A viewer should click Start.'
      : 'Î•Î½Î±Ï‚ Î¸ÎµÎ±Ï„Î®Ï‚ Î±Ï‚ ÎºÎ¬Î½ÎµÎ¹ ÎºÎ»Î¹Îº ÏƒÏ„Î·Î½ ÎˆÎ½Î±ÏÎ¾Î·';
  }
  if(startBtn){
    // Always use the short button label (donâ€™t let UI override it with longer text).
    startBtn.textContent = (currentLang==='en') ? 'Start' : 'ÎˆÎ½Î±ÏÎ¾Î·';
  }

  // Î¤Î¯Ï„Î»Î¿Î¹ Î ÏÎ¬Î¾Î·Ï‚ 3 (ÏŒÏ€Ï‰Ï‚ ÎºÎ±Î¹ Ï„Ï‰Î½ Î¬Î»Î»Ï‰Î½): Î±Ï€ÏŒ uiTitles.act3
  const act3BreakTitleEl = document.getElementById('act3BreakTitle');
  const act3TeaserEl = document.getElementById('act3Teaser');
  if(UI_TITLES && UI_TITLES.act3 && UI_TITLES.act3.signTitle != null){
    const t3 = expandDynTemplate(String(UI_TITLES.act3.signTitle));
    if(act3BreakTitleEl) act3BreakTitleEl.textContent = t3;
    if(act3TeaserEl) act3TeaserEl.textContent = t3;
  }

  // Control tooltips (Î¼Ï€Î±Î»Î¿Î½Î¬ÎºÎ¹Î±) â€” Î¼Îµ fallbacks Î±Î½ Î»ÎµÎ¯Ï€Î¿Ï…Î½ Î±Ï€ÏŒ UI
  if(btnNav){
    const fb = (currentLang==='en') ? 'transitions' : 'Î¼ÎµÏ„Î±Î²Î¬ÏƒÎµÎ¹Ï‚';
    btnNav.title = (ui.btnNavTitle != null) ? ui.btnNavTitle : fb;
  }
  if(btnPause){
    const fb = (currentLang==='en') ? 'pause' : 'Ï€Î±ÏÏƒÎ·';
    btnPause.title = (ui.btnPauseTitle != null) ? ui.btnPauseTitle : fb;
  }
  if(btnPlay){
    const fb = (currentLang==='en') ? 'play' : 'ÎºÎ±Î½Î¿Î½Î¹ÎºÎ¬';
    btnPlay.title = (ui.btnPlayTitle != null) ? ui.btnPlayTitle : fb;
  }
  if(btnReset){
    const fb = 'reset';
    btnReset.title = (ui.btnResetTitle != null) ? ui.btnResetTitle : fb;
  }
  if(btnNext){
    const fb = (currentLang==='en') ? 'next' : 'ÎµÏ€ÏŒÎ¼ÎµÎ½Î¿';
    btnNext.title = (ui.btnNextTitle != null) ? ui.btnNextTitle : fb;
  }
  if(btnBook){
    const locked = btnBook.disabled || btnBook.hasAttribute('disabled');
    const fb = locked
      ? ((currentLang==='en') ? 'Available after Act 1 ends' : 'Î”Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î¿ Î¼ÎµÏ„Î¬ Ï„Î¿ Ï„Î­Î»Î¿Ï‚ Ï„Î·Ï‚ Î ÏÎ¬Î¾Î·Ï‚ 1')
      : ((currentLang==='en') ? 'Performance Book' : 'Î’Î¹Î²Î»Î¯Î¿ Î Î±ÏÎ¬ÏƒÏ„Î±ÏƒÎ·Ï‚');

    if(locked && ui.btnBookTitleLocked != null) btnBook.title = ui.btnBookTitleLocked;
    else if(!locked && ui.btnBookTitle != null) btnBook.title = ui.btnBookTitle;
    else if(ui.btnBookTitle != null) btnBook.title = ui.btnBookTitle;
    else btnBook.title = fb;
  }

  // Act 3 button text/title (Î¹Î´Î¯Ï‰Ï‚ ÏŒÏ„Î±Î½ ÎµÎ¯Î½Î±Î¹ disabled)
  const btnAct3El = document.getElementById('btnAct3');
  if(btnAct3El){
    const locked = btnAct3El.disabled || btnAct3El.getAttribute('aria-disabled') === 'true';
    const fbText  = (currentLang==='en') ? 'Start Act 3' : 'ÎˆÎ½Î±ÏÎ¾Î· Î ÏÎ¬Î¾Î·Ï‚ 3';
    btnAct3El.textContent = (ui.btnAct3 != null) ? ui.btnAct3 : fbText;

    const fbTitle = locked
      ? ((currentLang==='en') ? 'Not available yet!' : 'Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Ï€ÏÎ¿Ï†Î±Î½ÏÏ‚ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î·!')
      : '';

    if(ui.btnAct3Title != null) btnAct3El.title = ui.btnAct3Title;
    else if(fbTitle) btnAct3El.title = fbTitle;
  }


  if(btnLangGR && btnLangEN){
    btnLangGR.classList.toggle('active', currentLang === 'gr');
    btnLangEN.classList.toggle('active', currentLang === 'en');
  }
}


function getTitleKeyForPhase(p){
  if(p==='countdown') return 'act1';
  if(p==='act1') return 'act1';
  if(p==='act2' || p==='between2andFoyer') return 'act2';
  if(p==='foyer') return 'foyer';
  if(p==='act3') return 'act3';
  return 'act1';
}


function applySignPatch(patch){
  if(!patch) return;

  const signTitle = document.getElementById('signTitle');
  const signLineA = document.getElementById('signLineA');
  const signLineB = document.getElementById('signLineB');
  const signLineC = document.getElementById('signLineC');
  const signLineD = document.getElementById('signLineD');

  if(signTitle && patch.signTitle != null) signTitle.textContent = expandDynTemplate(patch.signTitle);
  if(signLineA && patch.signLineA != null) signLineA.textContent = expandDynTemplate(patch.signLineA);
  if(signLineB && patch.signLineB != null) signLineB.innerHTML   = expandDynTemplate(patch.signLineB);
  if(signLineC && patch.signLineC != null) signLineC.textContent = expandDynTemplate(patch.signLineC);
  if(signLineD && patch.signLineD != null) signLineD.textContent = expandDynTemplate(patch.signLineD);
}

function applySignboardForPhase(p=phase){
  const key=getTitleKeyForPhase(p);

  const hasTitles = UI_TITLES && (UI_TITLES.act1 || UI_TITLES.act2 || UI_TITLES.foyer || UI_TITLES.act3);
  if(hasTitles && UI_TITLES[key]){
    applySignPatch(UI_TITLES[key]);
    return;
  }

  if(key==='act3'){
    applySignPatch({
      signTitle: 'Î Î¡Î‘ÎÎ— 3Î·',
      signLineA: 'Î¤ÎµÎ»Î¹ÎºÎ® Î ÏÎ¬Î¾Î· (ÏƒÏÎ½Ï„Î¿Î¼Î±)',
      signLineB: '',
      signLineC: '',
      signLineD: ''
    });
    return;
  }

  applySignPatch(UI || {});
}
function setFoyerTitles(){
  if(!foyerTitle1 || !foyerTitle2) return;

  // Î Î±Î¯ÏÎ½Î¿Ï…Î¼Îµ 2 Î³ÏÎ±Î¼Î¼Î­Ï‚ Î±Ï€ÏŒ Ï„Î¿Ï…Ï‚ Ï„Î¯Ï„Î»Î¿Ï…Ï‚ Î¦Î¿Ï…Î±Î³Î¹Î­ (Ï€ÏÎ¿Ï„ÎµÏÎ±Î¹ÏŒÏ„Î·Ï„Î± uiTitles.foyer)
  const hasTitles = UI_TITLES && UI_TITLES.foyer;
  const t = hasTitles ? UI_TITLES.foyer : (UI || {});

  const line1 = (t.signTitle != null ? t.signTitle : '');
  const line2 = (t.signLineA  != null ? t.signLineA  : '');

  foyerTitle1.textContent = expandDynTemplate(String(line1));
  foyerTitle2.innerHTML   = expandDynTemplate(String(line2));
}


/* ---------- Î’Î¿Î·Î¸Î·Ï„Î¹ÎºÎ¬ Î³Î¹Î± ÏƒÎºÎ·Î½Î® ---------- */

let _lastMarbleB = null;
let _marbleGrowT0 = 0;
function updateMarbleTrack(){
  const track = document.getElementById('marbleTrack');
  const trackGhost = document.getElementById('marbleTrackGhost');
  const actorImg = document.querySelector('#actor img');

  if(!track || !actorImg || !stage) return;

  // Î¤Î¿ â€œÎ¼Î¬ÏÎ¼Î±ÏÎ¿â€ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î¼ÏŒÎ½Î¿ ÏƒÏ„Î¹Ï‚ Î ÏÎ¬Î¾ÎµÎ¹Ï‚ 1 & 2.
  const inActs = (phase==='act1' || phase==='act2');
  if(!inActs){
    track.style.display = 'none';
    if(trackGhost) trackGhost.style.display = 'none';
    return;
  }

  // IMPORTANT: Î· ÏƒÎºÎ·Î½Î® Ï€Î»Î­Î¿Î½ ÎºÎ»Î¹Î¼Î±ÎºÏÎ½ÎµÏ„Î±Î¹ Î¼Îµ CSS transform.
  // Î†ÏÎ± ÏŒ,Ï„Î¹ Î¼ÎµÏ„ÏÎ¬Î¼Îµ Î¼Îµ getBoundingClientRect() ÎµÎ¯Î½Î±Î¹ SCALED.
  // Î•Î´Ï Î´Î¿Ï…Î»ÎµÏÎ¿Ï…Î¼Îµ ÏƒÎµ *design px* (unscaled), Î¿Ï€ÏŒÏ„Îµ Î´Î¹Î±Î¹ÏÎ¿ÏÎ¼Îµ Î¼Îµ scale.
  const s = (()=>{
    const v = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--aat-scale'));
    return (isFinite(v) && v>0) ? v : 1;
  })();

  const stageRect = stage.getBoundingClientRect();
  const aRect = actorImg.getBoundingClientRect();

  const stageH = stage.clientHeight || 0;
  const actorBottomLocal = (aRect.bottom - stageRect.top) / s;

  // Î‘Ï€ÏŒ Ï„Î¿ CSS: top = (26% - 16px) ÎºÎ±Î¹ height = (44% + 24px)  => bottom = 70% + 8px.
  const curtainBottomClosedLocal = (0.70 * stageH) + 8;

  // ÎšÎ¬Î¸ÎµÏ„Î±: ÏÏˆÎ¿Ï‚ â€œÎ¼Î±ÏÎ¼Î¬ÏÎ¿Ï…â€ = (ÎºÎ¬Ï„Ï‰ Î¼ÎµÏƒÎ±Î¯Î±Ï‚ ÎºÎ¿Ï…ÏÏ„Î¯Î½Î±Ï‚) âˆ’ (ÎºÎ¬Ï„Ï‰ ÎµÎ¹ÎºÏŒÎ½Î±Ï‚ Î·Î¸Î¿Ï€Î¿Î¹Î¿Ï)
  const h = Math.max(0, curtainBottomClosedLocal - actorBottomLocal);
  // Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ· Î±Ï€ÏŒ Ï„Î¿ ÎºÎ¬Ï„Ï‰ Î¼Î­ÏÎ¿Ï‚ Ï„Î·Ï‚ ÏƒÎºÎ·Î½Î®Ï‚ Î¼Î­Ï‡ÏÎ¹ Ï„Î¿ ÎºÎ¬Ï„Ï‰ Ï„Î·Ï‚ Î¼ÎµÏƒÎ±Î¯Î±Ï‚ ÎºÎ¿Ï…ÏÏ„Î¯Î½Î±Ï‚ (ÏƒÏ„Î· Î¸Î­ÏƒÎ· Î·ÏÎµÎ¼Î¯Î±Ï‚)
  const bottomPx = Math.max(0, stageH - curtainBottomClosedLocal);

  // ÎŸÏÎ¹Î¶ÏŒÎ½Ï„Î¹Î± Î­ÎºÏ„Î±ÏƒÎ· Î¼Î±ÏÎ¼Î¬ÏÎ¿Ï…:
  // - Î“Î¹Î± b=0: Î¼Î¹ÎºÏÏŒ â€œÎ¼Î¬ÏÎ¼Î±ÏÎ¿â€ (x=-3 Î­Ï‰Ï‚ +3) ÏŒÏ€Ï‰Ï‚ Ï€ÏÎ¹Î½.
  // - Î“Î¹Î± bâ‰ 0: â€œÏ„ÏÎ­Ï‡ÎµÎ¹â€ Î±Ï€ÏŒ Ï„Î¿ ÎºÎ­Î½Ï„ÏÎ¿ Ï€ÏÎ¿Ï‚ Ï„Î± Î´ÎµÎ¾Î¹Î¬ ÎºÎ±Î¹ Î¼ÎµÎ³Î±Î»ÏÎ½ÎµÎ¹ Î±Ï€ÏŒ 0 â†’ Î¼Î­Ï‡ÏÎ¹ Ï„Î¿ Ï„Î­Î»Î¿Ï‚ Ï„Î·Ï‚ ÏƒÎºÎ·Î½Î®Ï‚.
  const cx = centerX();

  const bNow = (()=>{
    const el = document.getElementById('driveB');
    const v = el ? parseFloat(el.value) : 0;
    return isFinite(v) ? v : 0;
  })();

  // Color/class per b
  track.classList.remove('marble-b6','marble-b12','marble-b24','marble-bOther');
  if(bNow===6) track.classList.add('marble-b6');
  else if(bNow===12) track.classList.add('marble-b12');
  else if(bNow===24) track.classList.add('marble-b24');
  else if(bNow!==0) track.classList.add('marble-bOther');

  // Reset grow timer when b changes or when we re-enter acts.
  if(_lastMarbleB===null || _lastMarbleB!==bNow){
    _lastMarbleB = bNow;
    _marbleGrowT0 = performance.now();
  }

  let leftPx, widthPx;
  if(bNow===0){
    leftPx  = cx - 3*pxPerMeter;
    widthPx = Math.max(0, 6*pxPerMeter);
  }else{
    // bâ‰ 0: Î¼Î¬ÏÎ¼Î±ÏÎ¿ Î±Ï€ÏŒ x=0 Ï„Î¿Ï… Ï‡Î¬ÏÎ±ÎºÎ± (Î±ÏÎ¹ÏƒÏ„ÎµÏÏŒ Î¬ÎºÏÎ¿ ÏƒÎºÎ·Î½Î®Ï‚) Î¼Î­Ï‡ÏÎ¹ Î´ÎµÎ¾Î¯ Î¬ÎºÏÎ¿ ÏƒÎºÎ·Î½Î®Ï‚
    const stageW = (stage.clientWidth || 0);
    const targetWidth = Math.max(0, stageW);
    const t = Math.max(0, performance.now() - _marbleGrowT0);
    const g = Math.max(0, Math.min(1, t/900)); // ~0.9s grow
    leftPx  = 0;
    widthPx = targetWidth * g;
  }

  track.style.left  = leftPx + 'px';
  track.style.width = Math.max(0, widthPx) + 'px';
  track.style.bottom = bottomPx + 'px';
  track.style.height = h + 'px';
  track.style.display = (h>0) ? 'block' : 'none';

  // Ghost â€œÎ´Î¿ÎºÏŒÏ‚â€/Î¼Î¬ÏÎ¼Î±ÏÎ¿: Î±Ï€ÏŒ -5 Î­Ï‰Ï‚ +5, Î¼ÏŒÎ½Î¿ ÏŒÏ„Î±Î½ Î¿ ghost ÎµÎ¯Î½Î±Î¹ Î¿ÏÎ±Ï„ÏŒÏ‚.
  if(trackGhost){
    const gVis = (typeof ghostVisibility==='number') ? ghostVisibility : 0;
    if(phase==='act2' && gVis>0.02 && h>0){
      const gLeft  = cx - 5*pxPerMeter;
      const gRight = cx + 5*pxPerMeter;
      trackGhost.style.left   = gLeft + 'px';
      trackGhost.style.width  = Math.max(0, gRight - gLeft) + 'px';
      trackGhost.style.bottom = bottomPx + 'px';
      trackGhost.style.height = h + 'px';
      trackGhost.style.display = 'block';
      trackGhost.style.opacity = Math.min(0.65, 0.15 + 0.5*gVis).toString();
    }else{
      trackGhost.style.display = 'none';
    }
  }
}


function measureSpringNaturalSize(){
  if(!springEl) return;
  const prevDisplay   = springEl.style.display;
  const prevTransform = springEl.style.transform;

  springEl.style.display   = 'block';
  springEl.style.transform = 'none';

  // offsetWidth/offsetHeight Î”Î•Î ÎµÏ€Î·ÏÎµÎ¬Î¶Î¿Î½Ï„Î±Î¹ Î±Ï€ÏŒ transform Ï„Î·Ï‚ ÏƒÎºÎ·Î½Î®Ï‚ (design px).
  springNaturalWidth  = springEl.offsetWidth  || 1;
  springNaturalHeight = springEl.offsetHeight || 1;

  springEl.style.display   = prevDisplay;
  springEl.style.transform = prevTransform;
}

function setAudienceLights(on){
  audienceLightsOn = !!on;

  const main = audienceMain;
  const extra = audienceExtra;
  const ct = document.querySelector('.curtain-top');
  const cu = document.querySelector('.curtain-upper');
  const csL = document.querySelector('.curtain-side.left');
  const csR = document.querySelector('.curtain-side.right');

  const elems = [main, extra, ct, cu, csL, csR].filter(Boolean);
  elems.forEach(el=>{
    el.classList.toggle('dimmed', !on);
  });

  if(on && viewersStrip){
    viewersStrip.querySelectorAll('.viewer-avatar').forEach(div=>{
      div.classList.remove('lit');
    });
  }
}

/* ---------- Ruler / Î¼ÎµÏ„ÏÎ®ÏƒÎµÎ¹Ï‚ ---------- */

function anchorX(){ return stage.clientWidth * 0.18; }

/* --- Phase 2: spring attaches to the moving slider (driver) ---
   Î¤Î¿ Î±ÏÎ¹ÏƒÏ„ÎµÏÏŒ Î¬ÎºÏÎ¿ Ï„Î¿Ï… spring Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Ï€Î¹Î± ÏƒÏ„Î±Î¸ÎµÏÏŒ ÏƒÏ„Î¿ anchorX.
   Î Î±Î¯ÏÎ½ÎµÎ¹ Ï„Î· Î¸Î­ÏƒÎ· Î±Ï€ÏŒ Ï„Î¿ "ÏƒÎ·Î¼ÎµÎ¯Î¿ Ï€ÏÏŒÏƒÎ´ÎµÏƒÎ·Ï‚" Ï€Î¬Î½Ï‰ ÏƒÏ„Î¿ slider.
   (Î¤Î¿ placement Ï„Î¿Ï… Î¼Î·Ï‡Î±Î½Î¹ÏƒÎ¼Î¿Ï ÎµÎ¾Î±ÎºÎ¿Î»Î¿Ï…Î¸ÎµÎ¯ Î½Î± ÎºÎ¿Ï…Î¼Ï€ÏÎ½ÎµÎ¹ ÏƒÏ„Î¿ anchorX ÏŒÏ€Ï‰Ï‚ Ï€ÏÎ¹Î½.)
*/
function springAnchorX(){
  // Î£Î—ÎœÎ‘ÎÎ¤Î™ÎšÎŸ: Î”ÎµÎ½ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ¼Îµ getBoundingClientRect ÎµÎ´Ï, Î³Î¹Î±Ï„Î¯ Î· ÏƒÎºÎ·Î½Î® Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ scaled/translated
  // ÎºÎ±Î¹ Ï„ÏŒÏ„Îµ Î¿Î¹ screen-coordinates Î´ÎµÎ½ Ï„Î±Î¹ÏÎ¹Î¬Î¶Î¿Ï…Î½ Î¼Îµ Ï„Î± CSS px Ï€Î¿Ï… Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ¼Îµ Î³Î¹Î± left/bottom.
  // Î˜Î­Î»Î¿Ï…Î¼Îµ Ï„Î¿ Î¬ÎºÏÎ¿ Ï„Î¿Ï… ÎµÎ»Î±Ï„Î·ÏÎ¯Î¿Ï… Î½Î± ÏƒÏ…Î¼Ï€Î¯Ï€Ï„ÎµÎ¹ Î¼Îµ Ï„Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿ Ï€ÏÏŒÏƒÎ´ÎµÏƒÎ·Ï‚ Ï„Î¿Ï… slider:
  // x_attach = anchorX() + shiftPx + (dx - dx0)
  const base = anchorX() + driverShiftPx();
  return base + (driverDx - driverDx0);
}



// --- Driver/Ruler ÎºÎ¿Î¹Î½Î® Î¼ÎµÏ„Î±Ï„ÏŒÏ€Î¹ÏƒÎ· (ÏƒÎ·Î¼ÎµÎ¯Ï‰ÏƒÎ·: Î¸Î± Ï„Î·Î½ Î±ÎºÎ¿Î»Î¿Ï…Î¸Î®ÏƒÎ¿Ï…Î½ ÎºÎ±Î¹ Î¬Î»Î»Î± Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î± Ï„Î·Ï‚ ÏƒÎºÎ·Î½Î®Ï‚) ---
const DRIVER_SHIFT_FACTOR = 0.50;   // << Î¼ÎµÏ„Î±Ï„ÏŒÏ€Î¹ÏƒÎ· Î¼Î·Ï‡Î±Î½Î¹ÏƒÎ¼Î¿Ï: 50% Ï„Î¿Ï… Ï€Î»Î¬Ï„Î¿Ï…Ï‚ Ï„Î¿Ï… (Î´ÎµÎ¾Î¹Î¬)
const DRIVER_SHIFT_REF    = 0.60;   // Î±Î½Î±Ï†Î¿ÏÎ¬ (Ï€Î±Î»Î¹ÏŒ calibration) Î³Î¹Î± Î¼ÎµÏ„Î±Ï„ÏŒÏ€Î¹ÏƒÎ· Ï„Î¿Ï… Î¬Î¾Î¿Î½Î±/Ï‡Î¬ÏÎ±ÎºÎ±

function driverW(){ return (drvSlider && drvSlider.offsetWidth) ? drvSlider.offsetWidth : 0; }
function driverShiftPx(){ return driverW() * DRIVER_SHIFT_FACTOR; }
function rulerAxisShiftPx(){ return driverW() * (DRIVER_SHIFT_REF - DRIVER_SHIFT_FACTOR); }

function centerX(){
  // Î˜Î­Î»Î¿Ï…Î¼Îµ Ï„Î¿ ÎºÎ­Î½Ï„ÏÎ¿ Ï„Î¿Ï… â€˜Î¼Î±ÏÎ¼Î¬ÏÎ¿Ï…â€™ (x=0 Ï„Î·Ï‚ Ï„Î±Î»Î¬Î½Ï„Ï‰ÏƒÎ·Ï‚) Î½Î± ÏƒÏ…Î¼Ï€Î¯Ï€Ï„ÎµÎ¹ Î¼Îµ Ï„Î¿ 10 m Ï„Î¿Ï… Ï‡Î¬ÏÎ±ÎºÎ±.
  if(stage && Number.isFinite(rulerZeroX) && Number.isFinite(pxPerMeter) && pxPerMeter>0){
    return rulerZeroX + RULER_CENTER_M*pxPerMeter;
  }
  const base = stage ? (stage.clientWidth * 0.5) : (window.innerWidth * 0.5);
  return base;
}

function equilibriumXpx(){
  // Î˜Î­ÏƒÎ· Î¹ÏƒÎ¿ÏÏÎ¿Ï€Î¯Î±Ï‚/Î¼Î·Î´ÎµÎ½Î¹ÏƒÎ¼ÏŒÏ‚: ÏƒÏ„Î¿ 10 m Ï„Î¿Ï… Ï‡Î¬ÏÎ±ÎºÎ±.
  // (Î”Î·Î». Î¿ Î·Î¸Î¿Ï€Î¿Î¹ÏŒÏ‚ Ï„Î±Î»Î±Î½Ï„ÏÎ½ÎµÏ„Î±Î¹ Î³ÏÏÏ‰ Î±Ï€ÏŒ 7â€“13 m ÏŒÏ„Î±Î½ A=3 m)
  if(!isFinite(rulerZeroX) || !isFinite(pxPerMeter) || pxPerMeter<=0) return centerX();
  return rulerZeroX + 10*pxPerMeter;
}


// --- Driver mech placement (Phase 1) ---
// Î£Ï„ÏŒÏ‡Î¿Ï‚: Ï„Î¿ Î¬ÎºÏÎ¿ Ï€ÏÏŒÏƒÎ´ÎµÏƒÎ·Ï‚ Ï„Î¿Ï… slider Î½Î± ÎºÎ¬Î¸ÎµÏ„Î±Î¹ Ï€Î¬Î½Ï‰ ÏƒÏ„Î¿ ÏƒÏ„Î±Î¸ÎµÏÏŒ ÏƒÏ„Î®ÏÎ¹Î³Î¼Î± (anchorX)
// ÎºÎ±Î¹ ÏƒÏ„Î¿ Î¯Î´Î¹Î¿ ÏÏˆÎ¿Ï‚ Î¼Îµ Ï„Î¿ ÎºÎ­Î½Ï„ÏÎ¿ Ï„Î¿Ï… ÎµÎ»Î±Ï„Î·ÏÎ¯Î¿Ï….
function updateDriverPlacement(){
  if(!driverMech || !drvSlider || !stage) return;

  // Î˜Î­Î»Î¿Ï…Î¼Îµ Ï„Î¿ ÏƒÏÏƒÏ„Î·Î¼Î± Î½Î± "Ï€Î±Ï„Î¬ÎµÎ¹" ÏƒÏ„Î· ÏƒÎºÎ·Î½Î®: Î±Î½Î±Ï†Î¿ÏÎ¬ Î±Ï€ÏŒ ÎšÎ‘Î¤Î©, ÏŒÏ‡Î¹ Î±Ï€ÏŒ Ï€Î¬Î½Ï‰.
  // ÎˆÏ„ÏƒÎ¹ ÏŒÏ„Î±Î½ Î¼Î¹ÎºÏÎ±Î¯Î½Î¿Ï…Î¼Îµ/Î¼ÎµÎ³Î±Î»ÏÎ½Î¿Ï…Î¼Îµ (CSS width), Î´ÎµÎ½ Ï‡Î¬Î½ÎµÎ¹ Ï„Î·Î½ ÎµÏ€Î±Ï†Î® Î¼Îµ Ï„Î¿ Ï€Î¬Ï„Ï‰Î¼Î±.
  const floorEl = document.querySelector('.floor');
  const floorBottom = floorEl ? (parseFloat(getComputedStyle(floorEl).bottom) || 0) : 0;

  const targetX = anchorX();

  const w = drvSlider.offsetWidth  || 1;
  const h = drvSlider.offsetHeight || 1;

  // Î ÏÎ¿ÏƒÎµÎ³Î³Î¹ÏƒÏ„Î¹ÎºÏŒ ÏƒÎ·Î¼ÎµÎ¯Î¿ Ï€ÏÏŒÏƒÎ´ÎµÏƒÎ·Ï‚ ÏƒÏ„Î¿ slider (ÏƒÎµ Ï€Î¿ÏƒÎ¿ÏƒÏ„Î¬ Ï„Î¿Ï… PNG)
  const attachX = w * 0.87;

  // ÎŸÏÎ¹Î¶ÏŒÎ½Ï„Î¹Î±: ÎºÎ¿Ï…Î¼Ï€ÏÎ½ÎµÎ¹ ÏƒÏ„Î¿ anchorX.
  // Î£Î—ÎœÎ•Î™Î©Î£Î—: Î¼ÎµÏ„Î±Ï†Î­ÏÎ¿Ï…Î¼Îµ ÎŸÎ›ÎŸ Ï„Î¿Î½ Î¼Î·Ï‡Î±Î½Î¹ÏƒÎ¼ÏŒ Î´ÎµÎ¾Î¹ÏŒÏ„ÎµÏÎ± ÎºÎ±Ï„Î¬ 60% Ï„Î¿Ï… Ï€Î»Î¬Ï„Î¿Ï…Ï‚ Ï„Î¿Ï….
  // Î‘Ï…Ï„Î® Î· Î¼ÎµÏ„Î±Ï„ÏŒÏ€Î¹ÏƒÎ· (shiftPx) Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï„Î·Î½ Î±ÎºÎ¿Î»Î¿Ï…Î¸Î®ÏƒÎ¿Ï…Î½ ÎºÎ±Î¹ Î¬Î»Î»Î± Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î± Ï„Î·Ï‚ ÏƒÎºÎ·Î½Î®Ï‚.
  // DRIVER_SHIFT_FACTOR: Î¼ÎµÏ„Î±Ï„ÏŒÏ€Î¹ÏƒÎ· Î¿ÏÎ¹Î¶ÏŒÎ½Ï„Î¹Î± Ï„Î¿Ï… Î¼Î·Ï‡Î±Î½Î¹ÏƒÎ¼Î¿Ï (Î¸Î± Ï„Î·Î½ Î±ÎºÎ¿Î»Î¿Ï…Î¸Î®ÏƒÎ¿Ï…Î½ ÎºÎ±Î¹ Î¬Î»Î»Î± Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î±)
  // Î–Î·Ï„Î¿ÏÎ¼ÎµÎ½Î¿: Î¼ÎµÏ„Î±ÎºÎ¯Î½Î·ÏƒÎ· Î±ÏÎ¹ÏƒÏ„ÎµÏÏŒÏ„ÎµÏÎ± Î³Î¹Î± Î½Î± ÎºÎµÏÎ´Î¯ÏƒÎ¿Ï…Î¼Îµ Ï‡ÏÏÎ¿.
  // (Î¡Ï…Î¸Î¼Î¯Î¶ÎµÏ„Î±Î¹ ÎšÎ•ÎÎ¤Î¡Î™ÎšÎ‘ Ï€Î¹Î¿ Ï€Î¬Î½Ï‰.)
  // const DRIVER_SHIFT_FACTOR = ...;

  const shiftPx = w * DRIVER_SHIFT_FACTOR;

  // --- Scotch yoke: ÎºÎµÎ½Ï„ÏÎ¬ÏÎ¹ÏƒÎ¼Î± Ï€ÎµÎ¯ÏÎ¿Ï… Î¼Î­ÏƒÎ± ÏƒÏ„Î· ÏƒÏ‡Î¹ÏƒÎ¼Î® Ï„Î¿Ï… slider ---
  // Î¤Î± PNG ÎµÎ¯Î½Î±Î¹ ÏƒÎµ ÎºÎ¿Î¹Î½ÏŒ canvas 196x306. Î˜Î­Î»Î¿Ï…Î¼Îµ, ÏƒÏ„Î·Î½ Î±ÏÏ‡Î¹ÎºÎ® ÏƒÏ„Î¬ÏƒÎ·, Ï„Î¿
  // ÎºÎ­Î½Ï„ÏÎ¿ Ï„Î¿Ï… Ï€ÎµÎ¯ÏÎ¿Ï… Î½Î± ÎµÎ¯Î½Î±Î¹ ÎºÎµÎ½Ï„ÏÎ±ÏÎ¹ÏƒÎ¼Î­Î½Î¿ ÏƒÏ„Î· ÏƒÏ‡Î¹ÏƒÎ¼Î® Ï„Î¿Ï… slider.
  // Î•Ï€ÎµÎ¹Î´Î® Ï„Î¿ slider Î¸Î± Î­Ï‡ÎµÎ¹ translateX (dx0) Î®Î´Î· Î±Ï€ÏŒ Ï„Î·Î½ Î±ÏÏ‡Î¹ÎºÎ® Î³Ï‰Î½Î¯Î±,
  // Ï„Î¿ placement (ox) Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï„Î¿ "Ï€ÏÎ¿-Î±Î½Ï„Î¹ÏƒÏ„Î±Î¸Î¼Î¯ÏƒÎµÎ¹", Î±Î»Î»Î¹ÏÏ‚ Î¾ÎµÏ†ÎµÏÎ³ÎµÎ¹.
  const Wc = 196, Hc = 306;
  const wheelCX = 107, wheelCY = 53;
  const pinCX0  = 138.2054, pinCY0 = 55.7901; // Î±Ï€ÏŒ Ï„Î¿ Î¯Î´Î¹Î¿ Ï„Î¿ peiros.png
  const slotCX  = 138.5; // ÎºÎ­Î½Ï„ÏÎ¿ ÏƒÏ‡Î¹ÏƒÎ¼Î®Ï‚ slider.png (ÏƒÎµ px Ï„Î¿Ï… canvas)
  const vx0 = pinCX0 - wheelCX, vy0 = pinCY0 - wheelCY;
  const e0  = Math.hypot(vx0, vy0);
  const phi0 = Math.atan2(vy0, vx0);
  const scale = w / Wc;
  const THETA0 = Math.PI/2; // Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï„Î±Î¹ÏÎ¹Î¬Î¶ÎµÎ¹ Î¼Îµ DRIVER_THETA0
  const pinX0 = wheelCX + e0 * Math.cos(phi0 + THETA0);
  const dx0 = (pinX0 - slotCX) * scale;
  driverDx0 = dx0;

  const ox = targetX - attachX - 13 + shiftPx - dx0;

  // ÎšÎ±Ï„Î±ÎºÏŒÏÏ…Ï†Î±: Ï€Î±Ï„Î¬ÎµÎ¹ ÏƒÏ„Î¿ Ï€Î¬Ï„Ï‰Î¼Î± (Î¯Î´Î¹Î¿ bottom Î³Î¹Î± ÏŒÎ»Î± Ï„Î± overlay PNG).
  // Î‘Î½ Ï‡ÏÎµÎ¹Î±ÏƒÏ„ÎµÎ¯ micro-tune (1â€“6px), Ï„Î¿ ÎºÎ¬Î½Î¿Ï…Î¼Îµ ÎµÎ´Ï.
  const rigBottom = Math.max(0, floorBottom-100);

  const imgs = [drvTable, drvWheel, drvSlider, drvPin].filter(Boolean);
  imgs.forEach(img=>{
    img.style.left   = ox + 'px';
    img.style.bottom = rigBottom + 'px';
    img.style.top    = 'auto';
  });
}
/* =========================
   Driver (Scotch yoke) motion â€” Phase 1
   - wheel & pin rotate
   - slider translates: x = rÂ·cos(theta)
   NOTE: Î¤Î¿ Î¿ÏÎ¹Î¶ÏŒÎ½Ï„Î¹Î¿ shift (DRIVER_SHIFT_FACTOR) Ï€Î¿Ï… ÎµÏ†Î±ÏÎ¼ÏŒÎ¶ÎµÏ„Î±Î¹ ÏƒÏ„Î¿ placement
         Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î±ÎºÎ¿Î»Î¿Ï…Î¸Î·Î¸ÎµÎ¯ Î±ÏÎ³ÏŒÏ„ÎµÏÎ± ÎºÎ±Î¹ Î±Ï€ÏŒ Î¬Î»Î»Î± Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î± Ï„Î·Ï‚ ÏƒÎºÎ·Î½Î®Ï‚.
   ========================= */
const DRIVER_THETA0 = Math.PI/2;
let driverTheta = DRIVER_THETA0;          // Î¾ÎµÎºÎ¹Î½Î¬Î¼Îµ ÏƒÏ„Î¿ ÎºÎ­Î½Ï„ÏÎ¿ (cos=0) Î³Î¹Î± Î½Î± "ÎºÎ¿Ï…Î¼Ï€ÏÎ½ÎµÎ¹"

// Î“Î¹Î± Î½Î± Ï†Î±Î¯Î½ÎµÏ„Î±Î¹ ÎºÎ±Î¸Î±ÏÎ¬ Î¿ ÏƒÏ…Î½Ï„Î¿Î½Î¹ÏƒÎ¼ÏŒÏ‚, Î±Î»Î»Î¬Î¶Î¿Ï…Î¼Îµ Ï„Î· ÏƒÏ…Ï‡Î½ÏŒÏ„Î·Ï„Î± ÏƒÎµ (Ï…Ï€Î¿)Ï€Î¿Î»Î»Î±Ï€Î»Î¬ÏƒÎ¹Î± Ï„Î·Ï‚ Î¹Î´Î¹Î¿ÏƒÏ…Ï‡Î½ÏŒÏ„Î·Ï„Î±Ï‚ f0.
let driveRatio = 0.00;                    // f = driveRatio Â· f0
let driverOmega = omega * driveRatio;     // rad/s

let driverDx  = 0;   // Ï„ÏÎ­Ï‡Î¿Î½ translateX Ï„Î¿Ï… slider (px, ÏƒÏ„Î¿ Î¯Î´Î¹Î¿ ÏƒÏÏƒÏ„Î·Î¼Î± Î¼Îµ Ï„Î¿ placement)
let driverDx0 = 0;   // translateX ÏƒÏ„Î·Î½ Î±ÏÏ‡Î¹ÎºÎ® ÏƒÏ„Î¬ÏƒÎ· (Î³Î¹Î± ÏƒÏ‰ÏƒÏ„ÏŒ ÎºÎ¿ÏÎ¼Ï€Ï‰Î¼Î±)
let driverAmpPx = 0; // Ï€Î»Î¬Ï„Î¿Ï‚ Î´Î¹ÎµÎ³Î­ÏÏ„Î· (amplitude Ï„Î¿Ï… dx) ÏƒÎµ px

// =========================
// Driven oscillator (Phase 3) â€” Î¼Îµ b (kg/s), ÏŒÏ‡Î¹ Î².
// ÎœÎ¿Î½Ï„Î­Î»Î¿: m xÂ¨ + b(xË™-yË™) + k((x-y)-L0)=0  , ÏŒÏ€Î¿Ï… y(t) ÎµÎ¯Î½Î±Î¹ Î· Î²Î¬ÏƒÎ· (slider).
//
// Î˜Î­Ï„Î¿Ï…Î¼Îµ u = (x - y) - L0  (ÏƒÏ‡ÎµÏ„Î¹ÎºÎ® ÎµÏ€Î¹Î¼Î®ÎºÏ…Î½ÏƒÎ· Ï‰Ï‚ Ï€ÏÎ¿Ï‚ Ï†Ï…ÏƒÎ¹ÎºÏŒ Î¼Î®ÎºÎ¿Ï‚).
// Î¤ÏŒÏ„Îµ: uÂ¨ + (b/m) uË™ + Ï‰0Â² u = -yÂ¨
// ÎºÎ±Î¹:  x = y + L0 + u
//
// Î•Ï€Î¹Î»Î¿Î³Î®: L0 = (cx - y0) ÏŒÏ€Î¿Ï… y0 ÎµÎ¯Î½Î±Î¹ Î· Î¸Î­ÏƒÎ· Î²Î¬ÏƒÎ·Ï‚ Ï„Î· ÏƒÏ„Î¹Î³Î¼Î® Ï€Î¿Ï… Î¼Ï€Î±Î¯Î½Î¿Ï…Î¼Îµ ÏƒÏ„Î¿ driven mode.
// =========================
let driveU = 0;        // px
let driveUd = 0;       // px/s
let driveInited = false;

let basePrevX = null;  // px
let basePrevV = null;  // px/s
let baseRefX  = null;  // px (y0)

let driveB = 0;        // kg/s  (b ÏƒÏ„Î· Î´ÏÎ½Î±Î¼Î· -bÂ·v)

const DRIVE_B_HARD_MIN = 0;   // ÎµÏ€Î¹Ï„ÏÎ­Ï€Î¿Ï…Î¼Îµ ÎºÎ±Î¹ b=0 (Î±Î¼ÎµÎ¯Ï‰Ï„Î·/Ï‡Ï‰ÏÎ¯Ï‚ Î±Ï€ÏŒÏƒÎ²ÎµÏƒÎ·)
const DRIVE_B_SAFE_MIN = 10;  // Ï†Ï…ÏƒÎ¹ÎºÏŒ/Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒ ÎºÎ±Ï„ÏÏ†Î»Î¹ Ï„Î¿Ï… ÏƒÏ…ÏƒÏ„Î®Î¼Î±Ï„Î¿Ï‚
const DRIVE_B_MAX = 50;



function snapBToPresets(v){
  const presets = [0,6,12,24,30];
  let best = presets[0], bestd = Infinity;
  for(const p of presets){
    const d = Math.abs(p - v);
    if(d < bestd){ bestd = d; best = p; }
  }
  return best;
}

// --- Driver controls hookup (f as ratio, b as kg/s) ---
const elDriveRatio   = document.getElementById('driveRatio');
const elDriveB       = document.getElementById('driveB');
const elDriveFreqVal = document.getElementById('driveFreqVal');
const elDriveBVal    = document.getElementById('driveBVal');

// Act3 safety: ÎºÎ»ÎµÎ¯Î´Ï‰Î¼Î± Î±Î»Î»Î±Î³ÏÎ½ b ÎºÎ±Î¹ f Î¼Î­Ï‡ÏÎ¹ Î½Î± ÏƒÏ„Î±Î¸ÎµÏÎ¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Ï„Î¿ Ï€Î»Î¬Ï„Î¿Ï‚ ÎºÎ±Î¹ Î½Î± ÎºÎ±Ï„Î±Î³ÏÎ±Ï†ÎµÎ¯.
let afBFLocked = false;
function setAFBFLocked(lock){
  afBFLocked = !!lock;
  const shouldLock = (phase === 'act3') && afBFLocked;
  if(elDriveRatio){ elDriveRatio.disabled = shouldLock; elDriveRatio.setAttribute('aria-disabled', shouldLock?'true':'false'); }
  if(elDriveB){     elDriveB.disabled     = shouldLock; elDriveB.setAttribute('aria-disabled', shouldLock?'true':'false'); }
}
let afRecordSeq = 0;
const afLastRecordedSeqByKey = Object.create(null);
function currentAFKey(){
  // Î¼Î¿Î½Î±Î´Î¹ÎºÏŒ â€œÎºÎ»ÎµÎ¹Î´Î¯â€ Î³Î¹Î± Ï„Î¿ record Ï€Î¿Ï… Ï€ÎµÏÎ¹Î¼Î­Î½Î¿Ï…Î¼Îµ: (b | ratio)
  const b = Number(driveB);
  const r = Number(driveRatio);
  return `${Number.isFinite(b)?b:0}|${Number.isFinite(r)?r.toFixed(2):'0.00'}`;
}
function notifyAFRecorded(){
  afRecordSeq++;
  const _k = currentAFKey();
  afLastRecordedSeqByKey[_k] = afRecordSeq;
  const key = currentAFKey();
  try{
    window.dispatchEvent(new CustomEvent('af:recorded', {
      detail:{ seq: afRecordSeq, key, b: Number(driveB), ratio: Number(driveRatio) }
    }));
  }catch(_e){}
}
async function waitNextAFRecord(expectedKey){
  return new Promise((resolve)=>{
    // Capture the "state of the world" when we start waiting.
    const startSeq = afRecordSeq;
    const startSeen = expectedKey ? (afLastRecordedSeqByKey[expectedKey] || 0) : 0;

    // If it was already recorded after we last changed params, resolve immediately.
    if(expectedKey && startSeen > 0 && startSeen >= startSeq){
      resolve({seq: startSeen, key: expectedKey});
      return;
    }

    const handler = (e)=>{
      const keyOk = !expectedKey ? true : (e && e.detail && e.detail.key === expectedKey);
      if(!keyOk) return;

      const seen = expectedKey ? (afLastRecordedSeqByKey[expectedKey] || 0) : afRecordSeq;
      const seqOk = seen > 0 && (seen > startSeen) && (seen >= startSeq);

      if(seqOk){
        window.removeEventListener('af:recorded', handler);
        resolve({seq: seen, key: expectedKey});
      }
    };

    window.addEventListener('af:recorded', handler);
  });
}



function updateDriveFreqLabel(){
  const f  = (driverOmega / (2*Math.PI));
  if(!elDriveFreqVal) return;

  if(driveRatio <= 0){
    elDriveFreqVal.textContent = `OFF Â· ${f.toFixed(2)} Hz`;
    return;
  }

  // Î“Î¹Î± b<10 Î´ÎµÎ½ â€œÏ€ÏÎ¿Î²Î¬Î»Î»Î¿Ï…Î¼Îµâ€ Ï„Î¿ f0 Ï‰Ï‚ Î­Î¾Ï„ÏÎ± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ (Î¼Î­Î½ÎµÎ¹ Î¼ÏŒÎ½Î¿ Î»ÏŒÎ³Î¿Ï‚ r)
  if(driveB < DRIVE_B_SAFE_MIN){
    elDriveFreqVal.textContent = `r=${driveRatio.toFixed(2)} Â· ${f.toFixed(2)} Hz`;
  } else {
    elDriveFreqVal.textContent = `${driveRatio.toFixed(2)} fâ‚€ Â· ${f.toFixed(2)} Hz`;
  }
}

function syncDriveUI(){
  if(elDriveRatio){
    // Ï€ÏÎ¿ÏƒÏ€Î±Î¸Î¿ÏÎ¼Îµ Î½Î± "ÎºÎ¿Ï…Î¼Ï€ÏÏƒÎ¿Ï…Î¼Îµ" ÏƒÎµ Ï…Ï€Î¬ÏÏ‡Î¿Ï…ÏƒÎ± ÎµÏ€Î¹Î»Î¿Î³Î®
    const v = driveRatio.toFixed(2);
    const opt = Array.from(elDriveRatio.options).find(o => (parseFloat(o.value).toFixed(2) === v));
    if(opt) elDriveRatio.value = opt.value;
  }
  updateDriveFreqLabel();

  if(elDriveB){
    elDriveB.value = String(Math.min(DRIVE_B_MAX, Math.max(DRIVE_B_HARD_MIN, Math.round(driveB))));
    if(elDriveBVal) elDriveBVal.textContent = `${Math.min(DRIVE_B_MAX, Math.max(DRIVE_B_HARD_MIN, Math.round(driveB)))} kg/s`;
  }
  // Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î± ÏƒÏ…Ï‡Î½Î¿Ï„Î®Ï„Ï‰Î½ ÏŒÏ„Î±Î½ b < 10
  applyFrequencySafetyByB(driveB);

}

// Î‘Î½ b < 10: â€œÎºÏŒÎ²Î¿Ï…Î¼Îµâ€ ÏƒÏ…Ï‡Î½ÏŒÏ„Î·Ï„ÎµÏ‚ ÎºÎ¿Î½Ï„Î¬ ÏƒÏ„Î¿Î½ ÏƒÏ…Î½Ï„Î¿Î½Î¹ÏƒÎ¼ÏŒ Î³Î¹Î± Î½Î± Î¼Î· Î²Î³ÎµÎ¹ Ï„Î¿ ÏƒÏÏƒÏ„Î·Î¼Î± ÎµÎºÏ„ÏŒÏ‚ Î¿ÏÎ¯Ï‰Î½.
// (Î”Î¹Î±Ï„Î·ÏÎ¿ÏÎ¼Îµ Ï„Î· Î´Ï…Î½Î±Ï„ÏŒÏ„Î·Ï„Î± Î½Î± Î´Î¿ÎºÎ¹Î¼Î¬ÏƒÎµÎ¹Ï‚ Î¼Î¹ÎºÏÏŒÏ„ÎµÏÎ¿ b, Î±Î»Î»Î¬ Î¼ÏŒÎ½Î¿ Î¼Îµ Î±ÏƒÏ†Î±Î»ÎµÎ¯Ï‚ ratios.)
// =========================
// Dynamic forbid Î±Î½Î¬ b Î¼Îµ cap ÏƒÏ„Î¿ A=6.5m (Ï‡Ï‰ÏÎ¯Ï‚ â€œÎºÏŒÏˆÎ¹Î¼Î¿â€ ÎºÎ±Î¹ Î±Ï€ÏŒ Ï„Î¹Ï‚ Î´ÏÎ¿ Ï€Î»ÎµÏ…ÏÎ­Ï‚ Ï„Î±Ï…Ï„ÏŒÏ‡ÏÎ¿Î½Î±)
//
// Î™Î´Î­Î±:
// - Î“Î¹Î± ÎºÎ¬Î¸Îµ b ÎºÏÎ±Ï„Î¬Î¼Îµ capLeft/capRight (ÏŒÏÎ¹Î¿ ratio ÏŒÏ€Î¿Ï… Ï„Î¿ Î‘ â€œÏƒÎºÎ¬ÎµÎ¹â€ > 5m).
// - Î‘Î½ â€œÏƒÎºÎ¬ÏƒÎµÎ¹â€ ÏƒÏ„Î· Î¼Î¹Î± Ï€Î»ÎµÏ…ÏÎ¬, Î±Ï€Î±Î³Î¿ÏÎµÏÎ¿Î½Ï„Î±Î¹ ÎœÎŸÎÎŸ Ï„Î± ratios Ï€ÏÎ¿Ï‚ Ï„Î¿ f0 ÏƒÏ„Î·Î½ Î¯Î´Î¹Î± Ï€Î»ÎµÏ…ÏÎ¬.
// - Î£Ï„Î¿ Î³ÏÎ¬Ï†Î·Î¼Î±, Î· ÎºÎ±Î¼Ï€ÏÎ»Î· Ï„ÎµÏÎ¼Î±Ï„Î¯Î¶ÎµÎ¹ Î¼Îµ Ï„ÎµÏ‡Î½Î·Ï„ÏŒ ÏƒÎ·Î¼ÎµÎ¯Î¿ A=6.5 ÏƒÏ„Î¿ ratio Ï€Î¿Ï… ÏƒÎºÎ¬ÎµÎ¹.
// =========================
const AMP_LIMIT_METERS = 6.5;

// coarse list (Î³Î¹Î± b>=10) â€” ÎºÏÎ±Ï„Î¬Î¼Îµ Ï„Î¿ â€œÏƒÏ†Î¹Ï‡Ï„ÏŒâ€ Ï€Î±Î¹Ï‡Î½Î¯Î´Î¹
const DRIVE_RATIOS_COARSE = [0.60, 0.75, 0.90, 1.00, 1.10, 1.20, 1.50];

// dense list (Î³Î¹Î± b<10) â€” Î³Î¹Î± Î½Î± Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î±ÏÎºÎµÏ„Î¬ ÏƒÎ·Î¼ÎµÎ¯Î± ÏƒÏ„Î¿Ï…Ï‚ Î´ÏÎ¿ ÎºÎ»Î¬Î´Î¿Ï…Ï‚
const DRIVE_RATIOS_DENSE = (() => {
  const a = [];
  for(let r=0.60; r<=1.500001; r+=0.05){
    const rr = Math.round(r*100)/100;
    if(rr === 1.00) continue; // Î³Î¹Î± b<10 Î´ÎµÎ½ Î´ÎµÎ¯Ï‡Î½Î¿Ï…Î¼Îµ Ï€Î¿Ï„Î­ f0 Ï‰Ï‚ ÎµÏ€Î¹Î»Î¿Î³Î®
    a.push(rr);
  }
  return a;
})();

// bKey -> { leftCap: number|null, rightCap: number|null }
const capsByB = new Map();

function bKeyFromB(bKgPerS){ return Math.max(0, Math.round(bKgPerS)); }

function getCaps(bKey){
  if(!capsByB.has(bKey)) capsByB.set(bKey, { leftCap: null, rightCap: null });
  return capsByB.get(bKey);
}

function setCap(bKey, ratio){
  const c = getCaps(bKey);
  const r = Number(ratio);
  if(!Number.isFinite(r)) return;

  // ÎšÏÎ±Ï„Î¬Î¼Îµ cap â€œÏ€Î¹Î¿ ÎºÎ¿Î½Ï„Î¬â€ ÏƒÏ„Î¿ 1.00 (Ï€ÏÎ¿Ï‚ Ï„Î¿Î½ ÏƒÏ…Î½Ï„Î¿Î½Î¹ÏƒÎ¼ÏŒ) Î±Î½Î¬ Ï€Î»ÎµÏ…ÏÎ¬.
  if(r < 1.0){
    c.leftCap = (c.leftCap == null) ? r : Math.max(c.leftCap, r);
  } else if(r > 1.0){
    c.rightCap = (c.rightCap == null) ? r : Math.min(c.rightCap, r);
  }
}

// Î‘Ï€Î±Î³ÏŒÏÎµÏ…ÏƒÎ· ÎœÎŸÎÎŸ Ï€ÏÎ¿Ï‚ f0 ÏƒÏ„Î·Î½ Î¯Î´Î¹Î± Ï€Î»ÎµÏ…ÏÎ¬
function isRatioDisabledForB(bKey, ratio){
  const c = getCaps(bKey);
  const r = Number(ratio);
  if(!Number.isFinite(r)) return false;

  if(c.leftCap != null && r < 1.0 && r >= c.leftCap) return true;   // [leftCap, 1)
  if(c.rightCap != null && r > 1.0 && r <= c.rightCap) return true; // (1, rightCap]
  return false;
}

// backward-compatible alias (Ï€Î±Î»Î¹ÏŒ ÏŒÎ½Î¿Î¼Î± Ï€Î¿Ï… Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½ ÎºÎ¬Ï€Î¿Î¹Î± ÏƒÎ·Î¼ÎµÎ¯Î±)
function isDisabledRatioForB(bKey, ratio){
  return isRatioDisabledForB(bKey, ratio);
}


function pickBestEnabledRatio(options, preferSide /* 'left'|'right'|null */){
  let enabled = options.filter(o => !o.disabled).map(o => Number(o.value)).filter(Number.isFinite);
  if(!enabled.length) return null;

  // ÎœÎ·Î½ ÎµÏ€Î¹Î»Î­Î³ÎµÎ¹Ï‚ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Ï„Î¿ OFF (0.00) Î±Î½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î¬Î»Î»ÎµÏ‚ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼ÎµÏ‚ ÎµÏ€Î¹Î»Î¿Î³Î­Ï‚.
  if(enabled.length > 1) enabled = enabled.filter(v => Math.abs(v) > 1e-12);

  let pool = enabled;
  if(preferSide === 'right'){
    const r = enabled.filter(v => v > 1.0);
    if(r.length) pool = r;
  } else if(preferSide === 'left'){
    const l = enabled.filter(v => v < 1.0);
    if(l.length) pool = l;
  }

  // â€œÎ±ÏƒÏ†Î±Î»Î­ÏƒÏ„ÎµÏÎ¿â€: Ï€Î¹Î¿ Î¼Î±ÎºÏÎ¹Î¬ Î±Ï€ÏŒ 1.00
  let best = pool[0], bestScore = -Infinity;
  for(const v of pool){
    const score = Math.abs(v - 1.0);
    if(score > bestScore){ bestScore = score; best = v; }
  }
  return best;
}

function rebuildDriveRatioOptions(bKgPerS, preferSide=null){
  if(!elDriveRatio) return;

  const bKey = bKeyFromB(bKgPerS);

  // Î£Ï„Î±Î¸ÎµÏÎ­Ï‚ Ï€ÏÎ¿ÎµÏ€Î¹Î»ÎµÎ³Î¼Î­Î½ÎµÏ‚ Ï„Î¹Î¼Î­Ï‚ ÏƒÏ…Ï‡Î½Î¿Ï„Î®Ï„Ï‰Î½ Î³Î¹Î± ÎŸÎ›Î‘ Ï„Î± b
  const ratios = [0.00, 0.60, 0.75, 0.90, 0.95, 1.00, 1.05, 1.15, 1.30, 1.45];

  const prev = String(elDriveRatio.value || '');
  elDriveRatio.innerHTML = '';

  for(const r of ratios){
    const opt = document.createElement('option');
    opt.value = r.toFixed(2);
    opt.textContent = (r === 0 ? 'OFF' : (r*100).toFixed(0) + '%');

    // Dynamic forbid (cap) Î³Î¹Î± Ï„Î¿ ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½Î¿ b + ÎµÎ¹Î´Î¹ÎºÏŒÏ‚ ÎºÎ±Î½ÏŒÎ½Î±Ï‚: Î³Î¹Î± b=6 Î±Ï€ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Ï„Î¿ 100%
    opt.disabled = isDisabledRatioForB(bKey, opt.value) || (bKey === 6 && opt.value === '1.00');

    elDriveRatio.appendChild(opt);
  }

  // Ï€ÏÎ¿ÏƒÏ€Î¬Î¸Î·ÏƒÎµ Î½Î± ÎºÏÎ±Ï„Î®ÏƒÎµÎ¹Ï‚ Ï„Î·Î½ Ï€ÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î· ÎµÏ€Î¹Î»Î¿Î³Î® Î±Î½ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÏ„Î±Î¹
  const canKeep = Array.from(elDriveRatio.options).some(o => o.value === prev && !o.disabled);
  if(canKeep){
    elDriveRatio.value = prev;
    return;
  }

  // Î±Î»Î»Î¹ÏÏ‚ Î´Î¹Î¬Î»ÎµÎ¾Îµ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î±
  const best = pickBestEnabledRatio(Array.from(elDriveRatio.options), preferSide);
  if(best != null){
    elDriveRatio.value = best.toFixed(2);

    // ÎµÎ½Î·Î¼Î­ÏÏ‰ÏƒÎ· ÎºÎ¹Î½Î·Ï„Î®ÏÎ± (Ï‡Ï‰ÏÎ¯Ï‚ Î½Î± Î²Î±ÏƒÎ¹Î¶ÏŒÎ¼Î±ÏƒÏ„Îµ ÏƒÏ„Î¿ 'change' event)
    const rr = Math.max(0.0, parseFloat(elDriveRatio.value) || 0.0);
    driveRatio = rr;
    driverOmega = omega * driveRatio;
    updateDriveFreqLabel();
    if (typeof AFRecorder !== 'undefined') AFRecorder.onFChange();
  }
}

// Î±Î½Ï„Î¹ÎºÎ±Î¸Î¹ÏƒÏ„Î¬ Ï„Î¿ Ï€Î±Î»Î¹ÏŒ â€œÎºÏŒÏˆÎ¹Î¼Î¿â€ ÏƒÏ…Ï‡Î½Î¿Ï„Î®Ï„Ï‰Î½
let _suppressFreqSafetyOnce = false; // Î³Î¹Î± Î´Î¹Î±Î»ÏŒÎ³Î¿Ï…Ï‚: Î¼Î·Î½ Î±Ï†Î®Î½ÎµÎ¹Ï‚ Ï„Î¿ safety Î½Î± Î±Î½Ï„Î¹ÎºÎ±Î¸Î¹ÏƒÏ„Î¬ ratio Ï€Î¿Ï… Î¼ÏŒÎ»Î¹Ï‚ Î²Î¬Î»Î±Î¼Îµ

function applyFrequencySafetyByB(bKgPerS){
  if(_suppressFreqSafetyOnce){ _suppressFreqSafetyOnce = false; return; }
  rebuildDriveRatioOptions(bKgPerS, null);
}

// ÎšÎ±Î»ÎµÎ¯Ï„Î±Î¹ Î±Ï€ÏŒ Ï„Î¿Î½ recorder ÏŒÏ„Î±Î½ â€œÏƒÎºÎ¬ÏƒÎµÎ¹â€ Î­Î½Î± (b,f): Î¸Î­Ï„ÎµÎ¹ cap + Î±Î½Î±Î½ÎµÏÎ½ÎµÎ¹ ÎµÏ€Î¹Î»Î¿Î³Î­Ï‚
function applyCapForCurrentBF(bKgPerS, fRatio){
  const bKey = bKeyFromB(bKgPerS);
  const r = Number(fRatio);
  if(!Number.isFinite(r)) return;

  setCap(bKey, r);

  // Î‘Î½ Î­ÏƒÎºÎ±ÏƒÎµ ÏƒÏ„Î·Î½ Î±ÏÎ¹ÏƒÏ„ÎµÏÎ® Ï€Î»ÎµÏ…ÏÎ¬, Ï€ÏÎ¿Ï„Î¯Î¼Î·ÏƒÎµ Î´ÎµÎ¾Î¹Î¬ (ÎºÎ±Î¹ Î±Î½Ï„Î¯ÏƒÏ„ÏÎ¿Ï†Î±)
  const prefer = (r < 1.0) ? 'right' : (r > 1.0 ? 'left' : null);
  rebuildDriveRatioOptions(bKgPerS, prefer);
}

if(elDriveRatio){
  elDriveRatio.addEventListener('change', () => {
    const r = Math.max(0.0, parseFloat(elDriveRatio.value) || 0.0);
    driveRatio = r;
    driverOmega = omega * driveRatio;
    updateDriveFreqLabel();
    if (typeof AFRecorder !== 'undefined') AFRecorder.onFChange();
  });
}

if(elDriveB){
  elDriveB.addEventListener('change', () => {
    const raw = parseFloat(elDriveB.value);
    driveB = snapBToPresets(Number.isFinite(raw) ? raw : 12);
    elDriveB.value = String(driveB);
    applyFrequencySafetyByB(driveB);
    if(elDriveBVal) elDriveBVal.textContent = `${driveB} kg/s`;
    if (typeof AFRecorder !== 'undefined') AFRecorder.onBChange();
  });
}

// Î±ÏÏ‡Î¹ÎºÎ¿Ï€Î¿Î¯Î·ÏƒÎ· UI Î±Ï€ÏŒ Ï„Î¹Ï‚ Ï„ÏÎ­Ï‡Î¿Ï…ÏƒÎµÏ‚ Ï„Î¹Î¼Î­Ï‚
syncDriveUI();

function applyDriverTransform(){
  if(!drvWheel || !drvPin || !drvSlider) return;

  // ÎšÎ¿Î¹Î½ÏŒ canvas Ï„Ï‰Î½ PNG (ÏŒÎ»Î± 196x306).
  // Î˜Î•ÎœÎ•Î›Î™Î©Î”Î•Î£: Ï„Î¿ "r" Ï„Î¿Ï… Scotch yoke Î”Î•Î ÎµÎ¯Î½Î±Î¹ Î· Î±ÎºÏ„Î¯Î½Î± Ï„Î¿Ï… Ï„ÏÎ¿Ï‡Î¿Ï.
  // Î•Î¯Î½Î±Î¹ Î· Î±Ï€ÏŒÏƒÏ„Î±ÏƒÎ·: ÎºÎ­Î½Ï„ÏÎ¿ Ï€ÎµÎ¯ÏÎ¿Ï… â†” ÎºÎ­Î½Ï„ÏÎ¿ Ï„ÏÎ¿Ï‡Î¿Ï (eccentric offset).
  const W = 196, H = 306;

  // ÎšÎ­Î½Ï„ÏÎ¿ Ï„ÏÎ¿Ï‡Î¿Ï (ÏƒÎµ px Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ PNG) â€” Î±Ï€ÏŒ Î¼Î­Ï„ÏÎ·ÏƒÎ· Ï„Ï‰Î½ PNG.
  const wheelCX = 107, wheelCY = 53;

  // ÎšÎ­Î½Ï„ÏÎ¿ Ï€ÎµÎ¯ÏÎ¿Ï… ÏŒÏ„Î±Î½ Î¸=0 (ÏƒÎµ px Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ PNG) â€” Î±Ï€ÏŒ Î¼Î­Ï„ÏÎ·ÏƒÎ· Ï„Î¿Ï… peiros.png.
  // (ÎŸ Ï€ÎµÎ¯ÏÎ¿Ï‚ ÎµÎ¯Î½Î±Î¹ ÏƒÎµ Î¾ÎµÏ‡Ï‰ÏÎ¹ÏƒÏ„ÏŒ PNG, Î±Î»Î»Î¬ ÏƒÏ„Î¿ Î¯Î´Î¹Î¿ canvas/ÏƒÏÏƒÏ„Î·Î¼Î±.)
  const pinCX0 = 138.21, pinCY0 = 55.79;

  // Pivot Î³Î¹Î± wheel+pin
  const originX = (wheelCX / W) * 100;
  const originY = (wheelCY / H) * 100;
  drvWheel.style.transformOrigin = originX.toFixed(2) + '% ' + originY.toFixed(2) + '%';
  drvPin.style.transformOrigin   = originX.toFixed(2) + '% ' + originY.toFixed(2) + '%';

  // Eccentric offset ÎºÎ±Î¹ Î±ÏÏ‡Î¹ÎºÎ® Î³Ï‰Î½Î¯Î± Ï„Î¿Ï… Ï€ÎµÎ¯ÏÎ¿Ï… Ï€Î¬Î½Ï‰ ÏƒÏ„Î¿ Î±ÏÏ‡Î¹ÎºÏŒ PNG (Î¸=0).
  const vx0 = pinCX0 - wheelCX;
  const vy0 = pinCY0 - wheelCY;
  const e0  = Math.hypot(vx0, vy0);          // <<< Î±Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ Ï„Î¿ ÏƒÏ‰ÏƒÏ„ÏŒ "r"
  const phi0 = Math.atan2(vy0, vx0);

  // ÎšÎ»Î¹Î¼Î¬ÎºÏ‰ÏƒÎ· (Ï„Î± PNG ÎºÎ»Î¹Î¼Î±ÎºÏÎ½Î¿Î½Ï„Î±Î¹ Î¼Îµ CSS width).
  const scale = (drvWheel.offsetWidth || W) / W;

  // Slider motion (Scotch yoke):
  // ÎšÎ±Î½ÏŒÎ½Î±Ï‚: (slotCenterX + dx) == pinCenterX  â‡’  dx = (pinX - slotCX)*scale
  // ÎˆÏ„ÏƒÎ¹ Ï„Î¿ ÎºÎ­Î½Ï„ÏÎ¿ Ï„Î¿Ï… Ï€ÎµÎ¯ÏÎ¿Ï… Î¼Î­Î½ÎµÎ¹ ÎºÎµÎ½Ï„ÏÎ±ÏÎ¹ÏƒÎ¼Î­Î½Î¿ ÏƒÏ„Î· ÏƒÏ‡Î¹ÏƒÎ¼Î® ÏƒÎµ ÏŒÎ»Î¿ Ï„Î¿Î½ ÎºÏÎºÎ»Î¿.
  const slotCX = 138.5; // ÎºÎ­Î½Ï„ÏÎ¿ ÏƒÏ‡Î¹ÏƒÎ¼Î®Ï‚ slider.png (ÏƒÎµ px Ï„Î¿Ï… canvas)
  const pinX = wheelCX + e0 * Math.cos(phi0 + driverTheta);
  const dx = (pinX - slotCX) * scale;
  driverDx = dx;
  driverAmpPx = e0 * scale;

  // Î•Ï†Î±ÏÎ¼Î¿Î³Î® transforms (pin Ï€Î¬Î½Ï‰ Î±Ï€ÏŒ slider Ï€Î±ÏÎ±Î¼Î­Î½ÎµÎ¹ Î»ÏŒÎ³Ï‰ z-index).
  drvWheel.style.transform  = 'rotate(' + driverTheta + 'rad)';
  drvPin.style.transform    = 'rotate(' + driverTheta + 'rad)';
  drvSlider.style.transform = 'translateX(' + dx.toFixed(2) + 'px)';
}


let _afFitW = null;
function fitAFCanvasToCurtain(){
  const cvs = document.getElementById('afCanvas');
  if(!cvs || !stage) return;
  const leftCurt = stage.querySelector('.curtain-side.left');
  if(!leftCurt) return;

  // Î¤Î¿ afCanvas ÎµÎ¯Î½Î±Î¹ *ÎµÎºÏ„ÏŒÏ‚* Ï„Î¿Ï… .stage, Î¬ÏÎ± Ï„Î¿ Ï„Î¿Ï€Î¿Î¸ÎµÏ„Î¿ÏÎ¼Îµ ÏƒÎµ screen px, Ï€Î¬Î½Ï‰ ÏƒÏ„Î·Î½ Î±ÏÎ¹ÏƒÏ„ÎµÏÎ® ÎºÎ¿Ï…ÏÏ„Î¯Î½Î±.
  const sRect = stage.getBoundingClientRect();
  const lRect = leftCurt.getBoundingClientRect();

  const pad = 16;
  const targetW = Math.max(190, Math.floor(lRect.width - pad*2));
  const targetH = 330;

  const leftPx = Math.round(lRect.left + pad);
  const topPx  = Math.round(sRect.bottom - targetH - pad);

  const key = targetW + 'x' + targetH + '@' + leftPx + ',' + topPx;
  if(cvs.dataset.fitKey === key) return;
  cvs.dataset.fitKey = key;

  cvs.style.left = leftPx + 'px';
  cvs.style.top  = topPx + 'px';
  cvs.style.bottom = '';
  cvs.style.width = targetW + 'px';
  cvs.style.height = targetH + 'px';

  // Canvas intrinsic size (Î³Î¹Î± Î½Î± Î¼Î· â€œÎ¶Î¿Ï…Î¼Î¬ÏÎµÎ¹â€ Î¸Î±Î¼Ï€Î¬)
  cvs.width  = targetW;
  cvs.height = targetH;

  // redraw if recorder is present
  if(typeof AFRecorder !== 'undefined' && AFRecorder){
    try{ AFRecorder.onBChange(); }catch(e){}
  }
}

function updateRuler(){
  // ÎœÎµÏ„ÏÎ¿Ï„Î±Î¹Î½Î¯Î± (ÏƒÎ±Î½ tape measure):
  // - Î¤Î¿ 0 Î¼Ï€Î±Î¯Î½ÎµÎ¹ ÎµÎ¼Ï†Î±Î½ÏÏ‚ ÎœÎ•Î£Î‘ ÏƒÏ„Î· ÏƒÎºÎ·Î½Î® (Î»Î¯Î³Î¿ Î´ÎµÎ¾Î¹Î¬ Î±Ï€ÏŒ Ï„Î·Î½ Î±ÏÎ¹ÏƒÏ„ÎµÏÎ® ÎºÎ¿Ï…ÏÏ„Î¯Î½Î±).
  // - ÎŸ Ï‡Î¬ÏÎ±ÎºÎ±Ï‚ Î±Ï€Î»ÏÎ½ÎµÏ„Î±Î¹ Î¼Î­Ï‡ÏÎ¹ Ï„Î¿ Î´ÎµÎ¾Î¯ Î¬ÎºÏÎ¿ Ï„Î¿Ï… stage, ÏÏƒÏ„Îµ Î¿Î¹ Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯ÎµÏ‚ Ï„Î¹Î¼Î­Ï‚ Î½Î± Î¼Ï€Î¿ÏÎ¿ÏÎ½
  //   Î½Î± â€œÏ‡Î¬Î½Î¿Î½Ï„Î±Î¹â€ Ï€Î¯ÏƒÏ‰ Î±Ï€ÏŒ Ï„Î· Î´ÎµÎ¾Î¹Î¬ ÎºÎ¿Ï…ÏÏ„Î¯Î½Î± (Î±Î½Î¬Î»Î¿Î³Î± Î¼Îµ Ï„Î± z-index).
  const sRect = stage.getBoundingClientRect();
  const stageW = stage.clientWidth;
  const s = getStageScale();

  let openLeft = 0;
  const leftCurt = stage.querySelector('.curtain-side.left');
  if(leftCurt){
    const lRect = leftCurt.getBoundingClientRect();
    openLeft = Math.max(0, Math.round((lRect.right - sRect.left)/s));
  }

  const RULER_LEFT_INSET_PX = 14; // Ï„Î¿ 0 Î½Î± Ï†Î±Î¯Î½ÎµÏ„Î±Î¹ Î¼Î­ÏƒÎ± ÏƒÏ„Î· ÏƒÎºÎ·Î½Î® (ÏŒÏ‡Î¹ Ï€Î¬Î½Ï‰ ÏƒÏ„Î·Î½ ÎºÎ¿Ï…ÏÏ„Î¯Î½Î±)
  rulerZeroX = Math.min(stageW - 1, Math.max(0, openLeft + RULER_LEFT_INSET_PX));

  const usableW = Math.max(0, stageW - rulerZeroX);

  rulerEl.style.left  = rulerZeroX + 'px';
  rulerEl.style.width = usableW + 'px';
  rulerEl.innerHTML   = '';

  const maxTick = Math.floor(usableW / pxPerMeter);
  for(let mTick=0; mTick<=maxTick; mTick++){
    const rel = mTick * pxPerMeter;

    const tDiv = document.createElement('div');
    tDiv.className='tick';
    tDiv.style.left = rel + 'px';
    rulerEl.appendChild(tDiv);

    const lbl = document.createElement('div');
    lbl.className='tick-label';
    lbl.textContent = mTick + ' m';
    lbl.style.left = rel + 'px';

    // ÎšÏÎ¬Ï„Î± Ï„Î¿ 0 Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ Î¿Ï€Ï„Î¹ÎºÏŒ Ï€ÎµÎ´Î¯Î¿ (Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬), Î¬ÏƒÎµ Ï„Î± Î´ÎµÎ¾Î¹Î¬ Î½Î± â€œÏ‡Î±Î¸Î¿ÏÎ½â€ Ï€Î¯ÏƒÏ‰ Î±Ï€ÏŒ Ï„Î·Î½ ÎºÎ¿Ï…ÏÏ„Î¯Î½Î±.
    if(mTick===0) lbl.style.transform = 'translateX(0)';
    rulerEl.appendChild(lbl);
  }

  fitAFCanvasToCurtain();
}

/* ---------- Î”ÎµÎ¹Î³Î¼Î±Ï„Î¿Î»Î·ÏˆÎ¯Î± tâ€“x (Ï€Î¯Î½Î±ÎºÎ±Ï‚ + Î²Î¹Î²Î»Î¯Î¿) ---------- */

function logMeasurement(tObs, xMeters){
  if(!obsStarted || mode==='pause') return;
  if(tObs - lastSampleObsTime < sampleInterval) return;
  lastSampleObsTime = tObs;

  const tr = document.createElement('tr');
  tr.className='new';
  tr.innerHTML =
    '<td>'+(++measureRowIdx)+'</td>'+
    '<td>'+tObs.toFixed(2)+'</td>'+
    '<td>'+xMeters.toFixed(2)+'</td>';
  measureTBody.appendChild(tr);
  TM.setTimeout(()=>tr.classList.remove('new'),650);
  try{ tr.scrollIntoView({block:'end'}); }catch(e){}

  // ÎšÎ±Ï„Î±Î³ÏÎ±Ï†Î® ÎºÎ±Î¹ Î³Î¹Î± Ï„Î¿ Î²Î¹Î²Î»Î¯Î¿
  BOOK_SAMPLES.push({
    idx: measureRowIdx,
    t: parseFloat(tObs.toFixed(2)),
    x: parseFloat(xMeters.toFixed(2))
  });
}

/* ---------- x(t) canvas ---------- */

function buildSeriesData(){
  const N = 240;
  const span = XT_TOTAL_T;
  const tArr = new Array(N+1);
  const xArr = new Array(N+1);
  for(let i=0;i<=N;i++){
    const tloc = (i/N)*span;
    tArr[i] = tloc;
    xArr[i] = A_m*Math.sin(omega*(tloc+obsStartPlaybackOffset));
  }
  return [tArr,xArr];
}

function initXTChart(){
  if(uXT) return;
  if(!xtChartEl) return;
  xtChartEl.style.display='block';
  const c = document.createElement('canvas');
  c.width = 210;
  c.height= 120;
  c.style.width='210px';
  c.style.height='120px';
  xtChartEl.innerHTML='';
  xtChartEl.appendChild(c);
  uXT = c;
  drawXTChart();
}

function drawXTChart(){
  if(!uXT) return;
  const ctx = uXT.getContext('2d');
  const w = uXT.width;
  const h = uXT.height;
  ctx.clearRect(0,0,w,h);

  const margin=14;
  const x0=margin;
  const x1=w-margin;
  const yTop=margin;
  const yBot=h-margin;

  const [tArr,xArr] = buildSeriesData();
  const tMin=0, tMax=XT_TOTAL_T;
  const xMaxAbs=A_m*1.1;

  function tToX(t){ return x0+(t-tMin)/(tMax-tMin)*(x1-x0); }
  function xToY(x){
    const mid=(yTop+yBot)/2;
    const amp=(yBot-yTop)/2;
    return mid-(x/xMaxAbs)*amp;
  }

  // Grid
  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,0.18)';
  ctx.lineWidth=1;
  ctx.setLineDash([3,3]);

  const tTicks=[0, T, 2*T];
  tTicks.forEach(t=>{
    const xf=tToX(t);
    ctx.beginPath();
    ctx.moveTo(xf,yTop);
    ctx.lineTo(xf,yBot);
    ctx.stroke();
  });

  const xTicks=[-A_m,0,A_m];
  xTicks.forEach(x=>{
    const yf=xToY(x);
    ctx.beginPath();
    ctx.moveTo(x0,yf);
    ctx.lineTo(x1,yf);
    ctx.stroke();
  });

  ctx.restore();

  // Î†Î¾Î¿Î½ÎµÏ‚ + Ï€Î»Î±Î¯ÏƒÎ¹Î¿
  ctx.strokeStyle='rgba(255,255,255,0.6)';
  ctx.lineWidth=1;
  ctx.setLineDash([]);

  const y0line=xToY(0);
  ctx.beginPath();
  ctx.moveTo(x0,y0line);
  ctx.lineTo(x1,y0line);
  ctx.stroke();

  const xAxis0=tToX(0);
  ctx.beginPath();
  ctx.moveTo(xAxis0,yTop);
  ctx.lineTo(xAxis0,yBot);
  ctx.stroke();

  ctx.beginPath();
  ctx.rect(x0,yTop,x1-x0,yBot-yTop);
  ctx.stroke();

  // ÎšÎ±Î¼Ï€ÏÎ»Î· x(t) Î²Î±ÏƒÎ¹ÎºÎ® (ÎºÎ¯Ï„ÏÎ¹Î½Î·) ÏƒÎµ 0..2T
  ctx.strokeStyle='#ffd27a';
  ctx.lineWidth=2;
  ctx.beginPath();
  for(let i=0;i<tArr.length;i++){
    const tx=tArr[i];
    const xx=xArr[i];
    const px=tToX(tx);
    const py=xToY(xx);
    if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.stroke();

  // Labels Î±Î¾ÏŒÎ½Ï‰Î½
  ctx.fillStyle='#fff';
  ctx.font='11px system-ui';
  ctx.fillText('x(t)', x0+4, yTop+10);

  ctx.font='10px system-ui';
  ctx.fillText('x (m)', x0+4, yTop-4);
  ctx.fillText('t (s)', x1-20, yBot+12);

  ctx.textAlign='center';
  ctx.fillText('0',   tToX(0),   yBot+10);
  ctx.fillText(T.toFixed(1),   tToX(T),   yBot+10);
  ctx.fillText((2*T).toFixed(1), tToX(2*T), yBot+10);
  ctx.textAlign='left';

  ctx.fillText('-A', x0+4, xToY(-A_m)+4);
  ctx.fillText('0',  x0+4, xToY(0)+4);
  ctx.fillText('+A', x0+4, xToY(+A_m)+4);

  // Î“ÏÎ±Î¼Î¼Î® x0
  const x0val=A_m*Math.sin(omega*(0+obsStartPlaybackOffset));
  const yx0=xToY(x0val);
  ctx.strokeStyle='rgba(255,255,255,0.7)';
  ctx.setLineDash([4,2]);
  ctx.beginPath();
  ctx.moveTo(x0,yx0);
  ctx.lineTo(x1,yx0);
  ctx.stroke();

  ctx.setLineDash([]);
  ctx.fillStyle='#ffd27a';
  ctx.font='10px system-ui';
  const labelX0='xâ‚€ â‰ˆ '+x0val.toFixed(2)+' m';
  ctx.fillText(labelX0, x0+4, yx0-4);

  /* ---------- XT MARK OVERLAY: Î½Î­Î¿ t=0 + ÎºÏŒÎºÎºÎ¹Î½Î· ÎºÎ±Î¼Ï€ÏÎ»Î· ---------- */
  if(xtMarkState.active){
    const tZero = xtZeroCrossingTime();
    const px = tToX(tZero);
    const py = xToY(0);

    // 1) ÎšÏŒÎºÎºÎ¹Î½Î· Î·Î¼Î¹Ï„Î¿Î½Î¹ÎºÎ® ÎºÎ±Î¼Ï€ÏÎ»Î· Î±Ï€ÏŒ tZero ÎºÎ±Î¹ Î³Î¹Î± 1 Ï€ÎµÏÎ¯Î¿Î´Î¿
    ctx.save();
    ctx.strokeStyle='rgba(255,80,80,0.9)';
    ctx.lineWidth=2;
    ctx.setLineDash([]);
    const chartTmax = XT_TOTAL_T;
    const tStart = tZero;
    const tEnd   = Math.min(chartTmax, tZero + T);
    const N2 = 200;
    ctx.beginPath();
    for(let i=0;i<=N2;i++){
      const t = tStart + (tEnd - tStart)*(i/N2);
      const tPrime = t - tStart;
      const xPred  = A_m*Math.sin(omega*tPrime);
      const px2    = tToX(t);
      const py2    = xToY(xPred);
      if(i===0) ctx.moveTo(px2,py2); else ctx.lineTo(px2,py2);
    }
    ctx.stroke();
    ctx.restore();

    // 2) ÎšÏŒÎºÎºÎ¹Î½Î· Î¿Ï…ÏÎ¬ (ÎºÎ¬Î¸ÎµÏ„Î·) Î±Î½ Î¶Î·Ï„Î·Î¸ÎµÎ¯
    if(xtMarkState.showTail){
      ctx.save();
      ctx.strokeStyle='rgba(255,80,80,0.75)';
      ctx.lineWidth=1.3;
      ctx.setLineDash([3,3]);
      ctx.beginPath();
      ctx.moveTo(px,yBot);
      ctx.lineTo(px,py);
      ctx.stroke();
      ctx.restore();
    }

    // 3) ÎšÏŒÎºÎºÎ¹Î½Î¿ marker ÏƒÏ„Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿ (tZero, x=0)
    ctx.save();
    ctx.fillStyle='rgba(255,80,80,0.95)';
    ctx.beginPath();
    ctx.arc(px,py,3,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // 4) Î§Î¬Ï€Î¹ "Î½Î­Î¿ t=0" + Î²Î­Î»Î¿Ï‚
    const labelText = (currentLang==='en') ? 'new t = 0' : 'Î½Î­Î¿ t = 0';
    ctx.save();
    ctx.font='10px system-ui';
    const textWidth = ctx.measureText(labelText).width;
    const padX = 6;
    const padY = 3;
    let labelX = px+10;
    let labelY = yTop;

    const pillHalfW = textWidth/2 + padX;
    if(labelX < x0 + pillHalfW + 4) labelX = x0 + pillHalfW + 4;
    if(labelX > x1 - pillHalfW - 4) labelX = x1 - pillHalfW - 4;

    const pillLeft   = labelX - pillHalfW;
    const pillTop    = labelY - (8 + padY);
    const pillWidth  = pillHalfW*2;
    const pillHeight = 16 + 2*padY;
    const r = 8;

    ctx.beginPath();
    let X = pillLeft, Y = pillTop, W2 = pillWidth, H2 = pillHeight;
    ctx.moveTo(X+r,Y);
    ctx.lineTo(X+W2-r,Y);
    ctx.quadraticCurveTo(X+W2,Y,X+W2,Y+r);
    ctx.lineTo(X+W2,Y+H2-r);
    ctx.quadraticCurveTo(X+W2,Y+H2,X+W2-r,Y+H2);
    ctx.lineTo(X+r,Y+H2);
    ctx.quadraticCurveTo(X,Y+H2,X,Y+H2-r);
    ctx.lineTo(X,Y+r);
    ctx.quadraticCurveTo(X,Y,X+r,Y);
    ctx.closePath();
    ctx.fillStyle='rgba(80,0,0,0.88)';
    ctx.strokeStyle='rgba(255,80,80,0.95)';
    ctx.lineWidth=1.3;
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle='rgba(255,230,230,0.98)';
    ctx.textBaseline='middle';
    ctx.textAlign='center';
    ctx.fillText(labelText,labelX,labelY);

    const arrowStartX = labelX;
    const arrowStartY = pillTop + pillHeight;
    const arrowEndX   = px;
    const arrowEndY   = py - 6;

    ctx.strokeStyle='rgba(255,80,80,0.95)';
    ctx.lineWidth=1.6;
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(arrowStartX,arrowStartY);
    ctx.lineTo(arrowEndX,arrowEndY);
    ctx.stroke();

    const angle = Math.atan2(arrowEndY-arrowStartY, arrowEndX-arrowStartX);
    const headLen = 8;
    ctx.beginPath();
    ctx.moveTo(arrowEndX,arrowEndY);
    ctx.lineTo(
      arrowEndX - headLen*Math.cos(angle - Math.PI/6),
      arrowEndY - headLen*Math.sin(angle - Math.PI/6)
    );
    ctx.lineTo(
      arrowEndX - headLen*Math.cos(angle + Math.PI/6),
      arrowEndY - headLen*Math.sin(angle + Math.PI/6)
    );
    ctx.closePath();
    ctx.fillStyle='rgba(255,80,80,0.95)';
    ctx.fill();

    ctx.restore();
  }
}


/* ---------- XT OVERLAY (Î¼ÎµÎ³Î¬Î»Î¿ Î´Î¹Î¬Î³ÏÎ±Î¼Î¼Î± xâ€“t Ï€Î¬Î½Ï‰ ÏƒÏ„Î· ÏƒÎºÎ·Î½Î®) ---------- */

let xtOverlayEnabled = false;
let xtOverlayCan = null;
let xtOverlayBuf = [];
let xtOverlayT0 = 0;
let xtOverlayLastNow = null;
let xtOverlayURange = 3.5;

function getStageScale(){
  const v = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--aat-scale'));
  return (isFinite(v) && v>0) ? v : 1;
}

function ensureXTOverlay(){
  if(xtOverlayCan || !stage) return;
  const c = document.createElement('canvas');
  c.id = 'xtOverlayCanvas';
  c.style.position = 'absolute';
  c.style.left = '0';
  c.style.top = '0';
  c.style.width = '100%';
  c.style.height = '100%';
  c.style.pointerEvents = 'none';
  c.style.zIndex = '1500';
  c.style.display = 'none';
  stage.appendChild(c);
  xtOverlayCan = c;
}

function setXTOverlay(on){
  const wantShow = !!on;
  ensureXTOverlay();
  if(!xtOverlayCan) return;

  if(wantShow){
    // Î ÏÏÏ„Î· ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ·: Î±ÏÏ‡Î¹ÎºÎ¿Ï€Î¿Î¯Î·ÏƒÎ·/Î¼Î·Î´ÎµÎ½Î¹ÏƒÎ¼ÏŒÏ‚ buffer.
    if(!xtOverlayEnabled){
      xtOverlayEnabled = true;
      xtOverlayBuf = [];
      xtOverlayT0 = 0;
      xtOverlayLastNow = null;
      xtOverlayURange = 3.5;
    }
    xtOverlayCan.style.display = 'block';
  }else{
    // Î‘Ï€ÏŒÎºÏÏ…ÏˆÎ· Î¼ÏŒÎ½Î¿. Î”ÎµÎ½ ÏƒÏ„Î±Î¼Î±Ï„Î¬ÎµÎ¹ Ï€Î¿Ï„Î­ Î· ÎºÎ±Ï„Î±Î³ÏÎ±Ï†Î®.
    xtOverlayCan.style.display = 'none';
  }
}

function xtOverlayLocalRect(){
  // DEBUG/confirm rendering: ÎºÎµÎ½Ï„ÏÎ¹ÎºÏŒ panel ÏƒÏ„Î· Î¼Î­ÏƒÎ· Ï„Î·Ï‚ ÏƒÎºÎ·Î½Î®Ï‚
  if(!stage) return {left:0,right:0,top:0,bottom:0};

  const s = getStageScale();
  const stageRect = stage.getBoundingClientRect();
  const W = stage.clientWidth || 0;
  const H = stage.clientHeight || 0;

  const w = Math.round(W*0.18);
  const h = Math.min(320, Math.max(160, Math.round(H*0.38)));

  const left  = Math.max(0, Math.round(W - w));
  const top   = Math.max(0, Math.round(H - h - 50));

  return { left, right:left+w, top, bottom:top+h };
}

function xtOverlayPushSample(tObs, uMeters){
  if(!xtOverlayEnabled || !xtOverlayCan) return;
  if(!isFinite(tObs) || !isFinite(uMeters)) return;

  const span = Math.max(12, 15*T); // ~15 Ï€ÎµÏÎ¯Î¿Î´Î¿Î¹
  xtOverlayBuf.push({t:tObs, u:uMeters});

  const cutoff = tObs - (span + 2*T);
  while(xtOverlayBuf.length && xtOverlayBuf[0].t < cutoff) xtOverlayBuf.shift();
}

function xtOverlayDraw(dt){
  if(!xtOverlayEnabled || !xtOverlayCan) return;
  if(xtOverlayCan.style.display === 'none') return;

  const rect = xtOverlayLocalRect();
  const x0 = rect.left;
  const x1 = rect.right;
  const yTop = rect.top;
  const yBot = rect.bottom;

  const W = x1-x0;
  const H = yBot-yTop;
  if(W<60 || H<50) return;

  // Resize backing canvas to stage px
  const wNeed = stage.clientWidth || 0;
  const hNeed = stage.clientHeight || 0;
  if(xtOverlayCan.width !== wNeed) xtOverlayCan.width = wNeed;
  if(xtOverlayCan.height!== hNeed) xtOverlayCan.height = hNeed;

  const ctx = xtOverlayCan.getContext('2d');
  ctx.clearRect(0,0,xtOverlayCan.width,xtOverlayCan.height);

  // Panel background (Î¼ÏŒÎ½Î¿ ÏƒÏ„Î¿ rect)
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.26)';
  ctx.strokeStyle = 'rgba(255,255,255,0.22)';
  ctx.lineWidth = 1;
  const r = 12;
  const X = x0+6, Y=yTop+6, WW=W-12, HH=H-12;
  ctx.beginPath();
  ctx.moveTo(X+r,Y);
  ctx.lineTo(X+WW-r,Y);
  ctx.quadraticCurveTo(X+WW,Y,X+WW,Y+r);
  ctx.lineTo(X+WW,Y+HH-r);
  ctx.quadraticCurveTo(X+WW,Y+HH,X+WW-r,Y+HH);
  ctx.lineTo(X+r,Y+HH);
  ctx.quadraticCurveTo(X,Y+HH,X,Y+HH-r);
  ctx.lineTo(X,Y+r);
  ctx.quadraticCurveTo(X,Y,X+r,Y);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();

  const marginL=24, marginR=16, marginT=18, marginB=20;
  const pxL = x0 + marginL;
  const pxR = x1 - marginR;
  const pyT = yTop + marginT;
  const pyB = yBot - marginB;

  const span = Math.max(12, 15*T);
  if(!xtOverlayBuf.length) return;

  const tNow = xtOverlayBuf[xtOverlayBuf.length-1].t;

  // Time window: 0 ÏƒÏ„Î·Î½ Î±ÏÏ‡Î®, Î¿Î»Î¯ÏƒÎ¸Î·ÏƒÎ· Î¼ÏŒÎ½Î¿ ÏŒÏ„Î±Î½ Î³ÎµÎ¼Î¯ÏƒÎµÎ¹.
  const desiredT0 = Math.max(0, tNow - span);
  if(tNow <= span){
    xtOverlayT0 = 0;
  }else{
    // Î±ÏÎ³Î® Î¿Î»Î¯ÏƒÎ¸Î·ÏƒÎ· (inertia)
    const alpha = Math.min(1, Math.max(0.02, (dt||0.016)*0.20));
    xtOverlayT0 = xtOverlayT0 + (desiredT0 - xtOverlayT0)*alpha;
  }
  const t0 = xtOverlayT0;
  const t1 = t0 + span;

    // Î¥-ÎºÎ»Î¯Î¼Î±ÎºÎ±: Î£Î¤Î‘Î˜Î•Î¡Î— ÎºÎ»Î¯Î¼Î±ÎºÎ± -6.5 m Î­Ï‰Ï‚ +6.5 m
  const uRange = 6.5;

  function tToX(t){
    return pxL + (t - t0) / (t1 - t0) * (pxR - pxL);
  }
  function uToY(u){
    const mid = (pyT+pyB)/2;
    return mid - (u / uRange) * ((pyB-pyT)/2);
  }

  // Grid + axes
  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,0.14)';
  ctx.lineWidth=1;
  ctx.setLineDash([3,3]);

  // time ticks: Î±ÏÎ±Î¹Î¬ labels Î³Î¹Î± Î½Î± Î¼Î· Ï„ÏÎµÎ»Î±Î¯Î½Î¿Ï…Î½
  let step = 1;
  if(span > 28) step = 6;
  else if(span > 16) step = 4;
  else if(span > 10) step = 2;

  const tStart = Math.ceil(t0/step)*step;
  for(let t=tStart; t<=t1+1e-9; t+=step){
    const x = tToX(t);
    ctx.beginPath();
    ctx.moveTo(x,pyT);
    ctx.lineTo(x,pyB);
    ctx.stroke();
  }

  // u ticks
  const uTicks = [-6.5, 0, 6.5];
  for(const u of uTicks){
    const y = uToY(u);
    ctx.beginPath();
    ctx.moveTo(pxL,y);
    ctx.lineTo(pxR,y);
    ctx.stroke();
  }

  ctx.restore();

  // axes bold
  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,0.55)';
  ctx.lineWidth=1;
  ctx.setLineDash([]);
  // time axis (u=0)
  const y0 = uToY(0);
  ctx.beginPath();
  ctx.moveTo(pxL,y0);
  ctx.lineTo(pxR,y0);
  ctx.stroke();
  // left border
  ctx.beginPath();
  ctx.moveTo(pxL,pyT);
  ctx.lineTo(pxL,pyB);
  ctx.stroke();
  // frame
  ctx.beginPath();
  ctx.rect(pxL,pyT,pxR-pxL,pyB-pyT);
  ctx.stroke();
  ctx.restore();

  // plot
  ctx.save();
  ctx.strokeStyle='rgba(255,210,90,0.95)';
  ctx.lineWidth=2;
  ctx.beginPath();
  let started = false;
  for(const p of xtOverlayBuf){
    if(p.t < t0 || p.t > t1) continue;
    const x = tToX(p.t);
    const y = uToY(p.u);
    if(!started){ ctx.moveTo(x,y); started = true; }
    else{ ctx.lineTo(x,y); }
  }
  if(started) ctx.stroke();
  ctx.restore();

  // labels
  ctx.save();
  ctx.fillStyle='rgba(255,255,255,0.92)';
  ctx.font='12px system-ui';
  const title = (currentLang==='en') ? 'xâ€“t (relative)' : 'xâ€“t (Ï‰Ï‚ Ï€ÏÎ¿Ï‚ Î¹ÏƒÎ¿ÏÏÎ¿Ï€Î¯Î±)';
  ctx.fillText(title, pxL+6, pyT+14);

  ctx.font='10px system-ui';
  ctx.textAlign='center';
  for(let t=tStart; t<=t1+1e-9; t+=step){
    const x = tToX(t);
    ctx.fillText(String(Math.round(t)), x, pyB+12);
  }
  ctx.textAlign='left';
  ctx.fillText('t (s)', pxR-28, y0-6);
  ctx.fillText('x (m)', pxL+2, pyT-4);
  ctx.restore();
}

/* ---------- ÎÏŒÎ¼Î¿Î¹ & mini-Î´Î¹Î±Î³ÏÎ¬Î¼Î¼Î±Ï„Î± ---------- */

let firstLawShown=false;

function localizeTrig(txt){
  if(!txt) return txt;
  if(currentLang==='gr'){
    return txt.replaceAll('sin','Î·Î¼').replaceAll('cos','ÏƒÏ…Î½');
  }
  return txt;
}

function addLaw(txt){
  const t=localizeTrig(expandDynTemplate(txt));
  if(!firstLawShown){
    firstLawShown=true;
    lawsPane.style.display='block';
  }
  const div=document.createElement('div');
  div.className='law-line';
  div.innerHTML=String(t).replaceAll('\n','<br>');
  lawsBody.appendChild(div);
}

function sizeLawCanvas(c){
  const w=210,h=120;
  c.width=w; c.height=h;
  c.style.width=w+'px';
  c.style.height=h+'px';
}

/* v(t), a(t), aâ€“x, xâ€“sin(Ï‰t) */

function drawVelocityChart(){
  if(!vCan) return;
  const ctx=vCan.getContext('2d');
  const w=vCan.width;
  const h=vCan.height;
  ctx.clearRect(0,0,w,h);

  const margin=18;
  const x0=margin;
  const x1=w-margin;
  const y0=h/2;

  const vmax=omega*A_m;
  const yAmp=(h/2-margin);
  const scaleV=yAmp/(1.1*vmax);

  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,0.18)';
  ctx.lineWidth=1;
  ctx.setLineDash([3,3]);

  const tTicks=[0,T/2,T];
  tTicks.forEach(t=>{
    const xf=x0+(x1-x0)*(t/T);
    ctx.beginPath();
    ctx.moveTo(xf,margin);
    ctx.lineTo(xf,h-margin);
    ctx.stroke();
  });

  const vTicks=[-vmax,-vmax/2,0,vmax/2,vmax];
  vTicks.forEach(v=>{
    const yf=y0-v*scaleV;
    ctx.beginPath();
    ctx.moveTo(x0,yf);
    ctx.lineTo(x1,yf);
    ctx.stroke();
  });

  ctx.restore();

  ctx.strokeStyle='rgba(255,255,255,0.6)';
  ctx.lineWidth=1;
  ctx.setLineDash([]);
  ctx.beginPath();
  ctx.moveTo(x0,y0);
  ctx.lineTo(x1,y0);
  ctx.moveTo(x0,margin);
  ctx.lineTo(x0,h-margin);
  ctx.stroke();

  ctx.beginPath();
  ctx.rect(x0,margin,x1-x0,h-2*margin);
  ctx.stroke();

  const N=200;
  ctx.strokeStyle='#ffd27a';
  ctx.lineWidth=2;
  ctx.beginPath();
  for(let i=0;i<=N;i++){
    const t=(i/N)*T;
    const v=vmax*Math.cos(omega*(t+obsStartPlaybackOffset));
    const xf=x0+(x1-x0)*(t/T);
    const yf=y0-v*scaleV;
    if(i===0) ctx.moveTo(xf,yf); else ctx.lineTo(xf,yf);
  }
  ctx.stroke();

  ctx.fillStyle='#fff';
  ctx.font='11px system-ui';
  const labelVt=(currentLang==='en')?'v(t)':'Ï…(t)';
  ctx.fillText(labelVt,x0+4,margin+10);

  ctx.font='10px system-ui';
  const vAxisLabel=(currentLang==='en')?'v (m/s)':'Ï… (m/s)';
  ctx.fillText(vAxisLabel,x0+4,margin-4);
  ctx.fillText('t',x1-6,y0+12);
  ctx.fillText('0',x0-10,y0+4);

  ctx.textAlign='center';
  ctx.fillText('0',x0,h-margin+10);
  ctx.fillText((T/2).toFixed(1),(x0+x1)/2,h-margin+10);
  ctx.fillText(T.toFixed(1),x1,h-margin+10);
  ctx.textAlign='left';

  const vmaxLabel=((currentLang==='en')?'v_max â‰ˆ ':'Ï…_max â‰ˆ ')+vmax.toFixed(2);
  ctx.fillText(vmaxLabel,x0+4,h-margin+4);
}

function drawAccelerationChart(){
  if(!aCan) return;
  const ctx=aCan.getContext('2d');
  const w=aCan.width;
  const h=aCan.height;
  ctx.clearRect(0,0,w,h);

  const margin=18;
  const x0=margin;
  const x1=w-margin;
  const y0=h/2;

  const amax=omega*omega*A_m;
  const yAmp=(h/2-margin);
  const scaleA=yAmp/(1.1*amax);

  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,0.18)';
  ctx.lineWidth=1;
  ctx.setLineDash([3,3]);

  const tTicks=[0,T/2,T];
  tTicks.forEach(t=>{
    const xf=x0+(x1-x0)*(t/T);
    ctx.beginPath();
    ctx.moveTo(xf,margin);
    ctx.lineTo(xf,h-margin);
    ctx.stroke();
  });

  const aTicks=[-amax,-amax/2,0,amax/2,amax];
  aTicks.forEach(a=>{
    const yf=y0-a*scaleA;
    ctx.beginPath();
    ctx.moveTo(x0,yf);
    ctx.lineTo(x1,yf);
    ctx.stroke();
  });

  ctx.restore();

  ctx.strokeStyle='rgba(255,255,255,0.6)';
  ctx.lineWidth=1;
  ctx.setLineDash([]);
  ctx.beginPath();
  ctx.moveTo(x0,y0);
  ctx.lineTo(x1,y0);
  ctx.moveTo(x0,margin);
  ctx.lineTo(x0,h-margin);
  ctx.stroke();

  ctx.beginPath();
  ctx.rect(x0,margin,x1-x0,h-2*margin);
  ctx.stroke();

  const N=200;
  ctx.strokeStyle='#ffd27a';
  ctx.lineWidth=2;
  ctx.beginPath();
  for(let i=0;i<=N;i++){
    const t=(i/N)*T;
    const a=-amax*Math.sin(omega*(t+obsStartPlaybackOffset));
    const xf=x0+(x1-x0)*(t/T);
    const yf=y0-a*scaleA;
    if(i===0) ctx.moveTo(xf,yf); else ctx.lineTo(xf,yf);
  }
  ctx.stroke();

  ctx.fillStyle='#fff';
  ctx.font='11px system-ui';
  ctx.fillText('a(t)',x0+4,margin+10);

  ctx.font='10px system-ui';
  ctx.fillText('a (m/sÂ²)',x0+4,margin-4);
  ctx.fillText('t',x1-6,y0+12);
  ctx.fillText('0',x0-10,y0+4);

  ctx.textAlign='center';
  ctx.fillText('0',x0,h-margin+10);
  ctx.fillText((T/2).toFixed(1),(x0+x1)/2,h-margin+10);
  ctx.fillText(T.toFixed(1),x1,h-margin+10);
  ctx.textAlign='left';

  const amaxLabel='a_max â‰ˆ '+amax.toFixed(2);
  ctx.fillText(amaxLabel,x0+4,h-margin+4);
}

function drawAxChart(){
  if(!axCan) return;
  const ctx=axCan.getContext('2d');
  const w=axCan.width;
  const h=axCan.height;
  ctx.clearRect(0,0,w,h);

  const margin=22;
  const x0=margin;
  const x1=w-margin;
  const y0=margin;
  const y1=h-margin;

  const xMid=(x0+x1)/2;
  const yMid=(y0+y1)/2;

  const amax=omega*omega*A_m;

  const pxPerX=(x1-x0)/(2*A_m);
  const pxPerA=(y1-y0)/(2*amax);

  function toCanvas(x,a){
    const cx=xMid+x*pxPerX;
    const cy=yMid-a*pxPerA;
    return {cx,cy};
  }

  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,0.18)';
  ctx.lineWidth=1;
  ctx.setLineDash([3,3]);

  const xTicks=[-A_m,-A_m/2,0,A_m/2,A_m];
  xTicks.forEach(x=>{
    const p=toCanvas(x,0);
    ctx.beginPath();
    ctx.moveTo(p.cx,y0);
    ctx.lineTo(p.cx,y1);
    ctx.stroke();
  });

  const aTicks=[-amax,-amax/2,0,amax/2,amax];
  aTicks.forEach(a=>{
    const p=toCanvas(0,a);
    ctx.beginPath();
    ctx.moveTo(x0,p.cy);
    ctx.lineTo(x1,p.cy);
    ctx.stroke();
  });

  ctx.restore();

  ctx.strokeStyle='rgba(255,255,255,0.6)';
  ctx.lineWidth=1;
  ctx.setLineDash([]);
  ctx.beginPath();
  ctx.moveTo(xMid,y0);
  ctx.lineTo(xMid,y1);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x0,yMid);
  ctx.lineTo(x1,yMid);
  ctx.stroke();

  ctx.strokeStyle='#ffd27a';
  ctx.lineWidth=2;
  ctx.beginPath();
  const pL=toCanvas(-A_m, omega*omega*A_m);
  const pR=toCanvas(+A_m,-omega*omega*A_m);
  ctx.moveTo(pL.cx,pL.cy);
  ctx.lineTo(pR.cx,pR.cy);
  ctx.stroke();

  ctx.fillStyle='#fff';
  ctx.font='11px system-ui';
  ctx.fillText('aâ€“x',x0+4,y0+10);

  ctx.font='10px system-ui';
  ctx.fillText('x (m)',x1-32,yMid-4);
  ctx.fillText('a (m/sÂ²)',xMid+6,y0+10);

  ctx.fillText('a = -Ï‰Â²Â·x',x0+4,y1-4);
  ctx.fillText('A = '+A_m.toFixed(2)+' m',x0+4,y1-18);
  const amaxLabel='a_max â‰ˆ '+amax.toFixed(2);
  ctx.fillText(amaxLabel,x0+4,y1-32);
}

function drawXSinChart(){
  if(!xsCan) return;
  const ctx=xsCan.getContext('2d');
  const w=xsCan.width;
  const h=xsCan.height;
  ctx.clearRect(0,0,w,h);

  const margin=22;
  const x0=margin;
  const x1=w-margin;
  const y0=margin;
  const y1=h-margin;

  const Smin=-1.1, Smax=+1.1;
  const xmin=-1.1*A_m, xmax=+1.1*A_m;

  function SToX(S){ return x0+(S-Smin)/(Smax-Smin)*(x1-x0); }
  function xToY(x){ return y1-(x-xmin)/(xmax-xmin)*(y1-y0); }

  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,0.18)';
  ctx.lineWidth=1;
  ctx.setLineDash([3,3]);

  const STicks=[-1,-0.5,0,0.5,1];
  STicks.forEach(S=>{
    const xx=SToX(S);
    ctx.beginPath();
    ctx.moveTo(xx,y0);
    ctx.lineTo(xx,y1);
    ctx.stroke();
  });

  const xTicks=[-A_m,-A_m/2,0,A_m/2,A_m];
  xTicks.forEach(x=>{
    const yy=xToY(x);
    ctx.beginPath();
    ctx.moveTo(x0,yy);
    ctx.lineTo(x1,yy);
    ctx.stroke();
  });

  ctx.restore();

  ctx.strokeStyle='rgba(255,255,255,0.6)';
  ctx.lineWidth=1;
  ctx.setLineDash([]);

  const xAxisS0=SToX(0);
  const yx0=xToY(0);

  ctx.beginPath();
  ctx.moveTo(xAxisS0,y0);
  ctx.lineTo(xAxisS0,y1);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x0,yx0);
  ctx.lineTo(x1,yx0);
  ctx.stroke();

  ctx.beginPath();
  ctx.rect(x0,y0,x1-x0,y1-y0);
  ctx.stroke();

  ctx.strokeStyle='#ffd27a';
  ctx.lineWidth=2;
  ctx.beginPath();
  const S1=-1,S2=+1;
  const x1L=A_m*S1;
  const x2L=A_m*S2;
  ctx.moveTo(SToX(S1),xToY(x1L));
  ctx.lineTo(SToX(S2),xToY(x2L));
  ctx.stroke();

  ctx.fillStyle='#fff';
  ctx.font='11px system-ui';
  const title=(currentLang==='en')?'xâ€“sin(Ï‰t)':'xâ€“Î·Î¼(Ï‰t)';
  ctx.fillText(title,x0+4,y0+10);

  ctx.font='10px system-ui';
  const xLabel='x (m)';
  const sLabel=(currentLang==='en')?'sin(Ï‰t)':'Î·Î¼(Ï‰t)';
  ctx.fillText(xLabel,x0+4,y0-4);
  ctx.fillText(sLabel,x1-40,y1+12);

  ctx.textAlign='center';
  ctx.fillText('-1',SToX(-1),y1+10);
  ctx.fillText('0', SToX(0), y1+10);
  ctx.fillText('+1',SToX(+1),y1+10);
  ctx.textAlign='left';

  ctx.fillText('-A',x0+4,xToY(-A_m)+4);
  ctx.fillText('0', x0+4,xToY(0)+4);
  ctx.fillText('+A',x0+4,xToY(+A_m)+4);
}

function ensureVelocityChart(){
  if(!vCan){
    vCan=document.createElement('canvas');
    lawCharts.appendChild(vCan);
  }
  sizeLawCanvas(vCan);
  drawVelocityChart();
}
function ensureAccelerationChart(){
  if(!aCan){
    aCan=document.createElement('canvas');
    lawCharts.appendChild(aCan);
  }
  sizeLawCanvas(aCan);
  drawAccelerationChart();
}
function ensureAxChart(){
  if(!axCan){
    axCan=document.createElement('canvas');
    lawCharts.appendChild(axCan);
  }
  sizeLawCanvas(axCan);
  drawAxChart();
}
function ensureXSinChart(){
  if(!xSinChartEl) return;
  xSinChartEl.style.display='block';
  if(!xsCan){
    xsCan=document.createElement('canvas');
    xSinChartEl.innerHTML='';
    xSinChartEl.appendChild(xsCan);
  }
  sizeLawCanvas(xsCan);
  drawXSinChart();
}

/* ---------- Î Î±ÏÎ¬Î¼ÎµÏ„ÏÎ¿Î¹ Î‘Î‘Î¤ & helpers Î³Î¹Î± Î²Î¹Î²Î»Î¯Î¿ ---------- */

function x0Val(){
  return A_m*Math.sin(omega*(0+obsStartPlaybackOffset));
}

function getPhi0Deg(){
  const phi0deg = ((omega*obsStartPlaybackOffset)*180/Math.PI+360)%360;
  return phi0deg;
}

function getV0(){
  // v(0) = Ï‰ A cos(Ï‰(0+offset))
  const v0 = omega*A_m*Math.cos(omega*(0+obsStartPlaybackOffset));
  return v0;
}

function getVSignSymbol(v0){
  const eps = 1e-6;
  if(v0>eps)  return 'Ï…>0';
  if(v0<-eps) return 'Ï…<0';
  return 'Ï…=0';
}

function getVSignWord(v0){
  const eps = 1e-6;
  if(currentLang==='en'){
    if(v0>eps)  return 'positive';
    if(v0<-eps) return 'negative';
    return 'zero';
  }else{
    if(v0>eps)  return 'Î¸ÎµÏ„Î¹ÎºÎ®';
    if(v0<-eps) return 'Î±ÏÎ½Î·Ï„Î¹ÎºÎ®';
    return 'Î¼Î·Î´ÎµÎ½Î¹ÎºÎ®';
  }
}

function showParamsBox(){
  const phi0deg = getPhi0Deg();
  const Ashow = (Number.isFinite(A_m) && Math.abs(A_m-Math.round(A_m))<1e-9) ? String(Math.round(A_m)) : A_m.toFixed(2);
  paramAEl.textContent  = 'A = '+Ashow+' m';
  paramWEl.textContent  = 'Ï‰ = '+omega.toFixed(3)+' rad/s';
  paramPhiEl.textContent= 'Ï†â‚€ = '+phi0deg.toFixed(1)+'Â°';
  paramsBoxEl.style.display='block';
}

/* ---------- Î˜ÎµÎ±Ï„Î­Ï‚ / bubbles Îº.Î»Ï€. (Î¯Î´Î¹Î¿Ï‚ ÎºÏÎ´Î¹ÎºÎ±Ï‚ ÏŒÏ€Ï‰Ï‚ Ï€ÏÎ¹Î½) ---------- */

function viewerInfo(idx1based){
  const i=(idx1based||1)-1;
  return VIEWERS[i] || VIEWERS[0] || null;
}

function viewerAnchor(idx1based){
  const vi=viewerInfo(idx1based);
  const leftFrac=0.18;
  const widthFrac=0.64;
  const frac=vi && typeof vi.xFrac==='number'
    ? vi.xFrac
    : (idx1based/(VIEWERS.length+1 || 2));
  const x=(leftFrac+widthFrac*frac)*stage.clientWidth;
  const y=stage.clientHeight*0.60;
  return {x,y,info:vi};
}

function getViewerAvatarCenter(idx1based){
  const idx0=(idx1based||1)-1;
  const div=viewersStrip.querySelector('.viewer-avatar[data-idx="'+idx0+'"]');
  const info=viewerInfo(idx1based);

  if(div){
    // Î ÎŸÎ›Î¥ Î£Î—ÎœÎ‘ÎÎ¤Î™ÎšÎŸ:
    // Î£Ï„Î¹Ï‚ Î ÏÎ¬Î¾ÎµÎ¹Ï‚ 1â€“2 Ï„Î± avatars Î¼ÎµÏ„Î±ÎºÎ¹Î½Î¿ÏÎ½Ï„Î±Î¹ (ACTS_AVATAR_OFFSET) ÏÏƒÏ„Îµ Î½Î± "ÎºÎ±Î¸Î¯ÏƒÎ¿Ï…Î½" ÏƒÏ„Î· ÏƒÎºÎ·Î½Î®,
    // Î±Î»Î»Î¬ Î¿Î¹ Î´Î¹Î¬Î»Î¿Î³Î¿Î¹/Î¼Ï€Î±Î»ÏŒÎ½Î¹Î± Î”Î•Î Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î±ÎºÎ¿Î»Î¿Ï…Î¸Î¿ÏÎ½ Î±Ï…Ï„Î® Ï„Î· Î¼ÎµÏ„Î±ÎºÎ¯Î½Î·ÏƒÎ·.
    // Î“Î¹â€™ Î±Ï…Ï„ÏŒ Î±Î³ÎºÏ…ÏÏÎ½Î¿Ï…Î¼Îµ Ï€Î¬Î½Ï„Î± ÏƒÏ„Î¿ baseBottom (Î±Ï€ÏŒ JSON), ÏŒÏ‡Î¹ ÏƒÏ„Î¿ Ï„ÏÎ­Ï‡Î¿Î½ style.bottom.
    const baseBottom=parseFloat(div.dataset.baseBottom || '0') || 0;

    const w = div.offsetWidth  || 0;
    const h = div.offsetHeight || 0;
    const left = parseFloat(div.style.left||'0') || 0;

    const cx = left + w/2;
    const cy = stage.clientHeight - baseBottom - h/2;
    return {x:cx,y:cy,info};
  }
  return viewerAnchor(idx1based);
}

function getActorBottomLocalDesign(){
  // y (px) Ï„Î¿Ï… ÎºÎ¬Ï„Ï‰ Î¬ÎºÏÎ¿Ï… Ï„Î¿Ï… Î·Î¸Î¿Ï€Î¿Î¹Î¿Ï Î¼Î­ÏƒÎ± ÏƒÏ„Î· ÏƒÎºÎ·Î½Î®, ÏƒÎµ *design px* (unscaled).
  if(!stage) return 0;
  const actorImg = document.querySelector('#actor img');
  if(!actorImg) return 0;

  const s = (()=>{
    const v = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--aat-scale'));
    return (isFinite(v) && v>0) ? v : 1;
  })();

  const stageRect = stage.getBoundingClientRect();
  const aRect = actorImg.getBoundingClientRect();
  return (aRect.bottom - stageRect.top) / s;
}


function tint(hex,alpha){
  const c=(hex||'#ffffff').replace('#','');
  const r=parseInt(c.slice(0,2),16)||255;
  const g=parseInt(c.slice(2,4),16)||255;
  const b=parseInt(c.slice(4,6),16)||255;
  return 'rgba('+r+','+g+','+b+','+alpha+')';
}

function hideAllViewerAvatars(){
  viewersStrip.querySelectorAll('.viewer-avatar').forEach(div=>{
    div.classList.remove('visible','lit');
  });
}
function showViewerAvatar(idx1based){
  hideAllViewerAvatars();
  const el=viewersStrip.querySelector('.viewer-avatar[data-idx="'+(idx1based-1)+'"]');
  if(!el) return;
  const base=parseFloat(el.dataset.baseBottom || '0') || 0;
  let bottom=base;
  if(phase==='act1' || phase==='act2'){
    bottom=base+ACTS_AVATAR_OFFSET;
  }
  el.style.bottom=bottom+'px';
  el.classList.add('visible');
  if(!audienceLightsOn){
    el.classList.add('lit');
  }
}


function showAllViewerAvatars(){
  if(!viewersStrip) return;
  viewersStrip.querySelectorAll('.viewer-avatar').forEach((el)=>{
    if(el.style.display==='none') return;
    const base=parseFloat(el.dataset.baseBottom || '0') || 0;
    el.style.bottom=base+'px';
    el.classList.add('visible');
    el.classList.remove('lit');
    el.style.opacity='1';
  });
}

async function runFoyerExitStrobe(){
  // ÎŸÎ¹ Î´Î¹Î¬Î»Î¿Î³Î¿Î¹ Î±Ï€Î¿Ï‡ÏÏÎ·ÏƒÎ·Ï‚ Ï€Î»Î­Î¿Î½ Î²ÏÎ¯ÏƒÎºÎ¿Î½Ï„Î±Î¹ ÏƒÏ„Î¿ dialogs-*.json (FOYER).
  // Î•Î´Ï Î¼Î­Î½ÎµÎ¹ Î¼ÏŒÎ½Î¿ Ï„Î¿ Î¿Ï€Ï„Î¹ÎºÏŒ ÎµÏ†Î­ Î±Ï€Î¿Ï‡ÏÏÎ·ÏƒÎ·Ï‚.
  await strobeExitWalk();
}

async function strobeExitWalk(){
  const curtain = document.getElementById('strobeCurtain');
  if(!curtain || !viewersStrip || !stage) return;

  // Î¦ÏÎ¿Î½Ï„Î¯Î¶Î¿Ï…Î¼Îµ Î½Î± Ï†Î±Î¯Î½Î¿Î½Ï„Î±Î¹ ÏŒÎ»Î¿Î¹ Î¿Î¹ Î¿Î¼Î¹Î»Î·Ï„Î­Ï‚ (ÏŒÏÎ¸Î¹Î¿Î¹)
  showAllViewerAvatars();
  if(foyerBubble) foyerBubble.style.display='none';
  if(actBubble)   actBubble.style.display='none';

  // Hide foyer titlebar during exit (we will show Act 3 titles instead)
  const foyerTitlebarEl = document.getElementById('foyerTitlebar');
  if(foyerTitlebarEl) foyerTitlebarEl.style.display='none';

  // Enable exit mask so speakers can pass behind it on the right edge
  document.body.classList.add('exit-mask-active');

  // --- Strobe mode: blackout Ï€Î¬Î½Ï‰ Î±Ï€ÏŒ ÎŸÎ›Î— Ï„Î· ÏƒÎºÎ·Î½Î® ---
  document.body.classList.add('strobe-active');
  curtain.style.display='block';
  curtain.style.opacity='1'; // Î¾ÎµÎºÎ¹Î½Î¬Î¼Îµ ÏƒÎºÎ¿Ï„Î¬Î´Î¹


  // strobe flashes Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎµÎ¯Î½Î±Î¹ ÏƒÏ„Î¹Î³Î¼Î¹Î±Î¯Î± (Ï‡Ï‰ÏÎ¯Ï‚ fade)
  curtain.style.transition = 'opacity 0ms linear';
  const actors=[...viewersStrip.querySelectorAll('.viewer-avatar')]
    .filter(el=>el && el.style.display!=='none');
  const n = actors.length;

  // split: Î¿Î¹ 1 & 2 Î´ÎµÎ¾Î¹Î¬, Î¿Î¹ Ï…Ï€ÏŒÎ»Î¿Î¹Ï€Î¿Î¹ Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬ (0-based: 0,1)
  const RIGHT_SET = new Set([0,1]);
  const rightIdxs = Array.from({length:n},(_,i)=>i).filter(i=>RIGHT_SET.has(i));
  const leftIdxs  = Array.from({length:n},(_,i)=>i).filter(i=>!RIGHT_SET.has(i));
  const rankIn = (arr,i)=>arr.indexOf(i);
  const spreadIn = (arr,i,spreadPx)=>{
    const k = arr.indexOf(i);
    if(k<0) return 0;
    return (k - (arr.length-1)/2) * spreadPx;
  };

  if(!n){
    document.body.classList.remove('strobe-active');
    curtain.style.display='none';
    curtain.style.opacity='1';
    return;
  }

  // ÎºÏÎ±Ï„Î¬Î¼Îµ Î±ÏÏ‡Î¹ÎºÎ­Ï‚ Î¸Î­ÏƒÎµÎ¹Ï‚ Î³Î¹Î± restore (Î±Î½ Ï‡ÏÎµÎ¹Î±ÏƒÏ„ÎµÎ¯)
  const orig = actors.map(el=>({el,left:el.style.left,bottom:el.style.bottom,opacity:el.style.opacity}));

  const stageW = stage.clientWidth || 900;

  // base layout (bottoms)
  const bottoms = actors.map(el=>{
    const b = parseFloat(el.style.bottom||'0');
    return isFinite(b)? b : 0;
  });
  const baseBMax = Math.max(...bottoms);
  const standB = baseBMax + 26; // Â«ÏŒÏÎ¸Î¹Î¿Î¹Â»

  // --- Strobe tuning (Î±Ï€ÏŒ ÏÏ…Î¸Î¼Î¯ÏƒÎµÎ¹Ï‚ exit_tuner) ---
  const flashOnMs    = 18;   // Î¿ÏÎ±Ï„ÏŒ ÎºÎ±ÏÎ­
  const flashOffMs   = 75;   // ÏƒÎºÎ¿Ï„Î¬Î´Î¹ (Î¼ÎµÏ„Î±ÎºÎ¯Î½Î·ÏƒÎ· Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ ÏƒÎºÎ¿Ï„Î¬Î´Î¹)
  const holdLitMs    = 120;  // Ï†ÏÏ„Î± ON Î¼ÎµÏ„Î¬ Î±Ï€ÏŒ ÎºÎ¬Î¸Îµ burst

  const preBlackMs   = 100;  // Ï€ÏÏÏ„Î¿ ÏƒÎºÎ¿Ï„Î¬Î´Î¹ (Î¿ Ï€Î¯Î½Î±ÎºÎ±Ï‚ Ï†ÎµÏÎ³ÎµÎ¹ Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ ÏƒÎºÎ¿Ï„Î¬Î´Î¹)
  const finalBlackMs = 1000; // Ï„ÎµÎ»Î¹ÎºÏŒ ÏƒÎºÎ¿Ï„Î¬Î´Î¹ Ï€ÏÎ¹Î½ ÎµÎ¾Î±Ï†Î±Î½Î¹ÏƒÏ„Î¿ÏÎ½ + Î±Î»Î»Î¬Î¾ÎµÎ¹ Ï„Î¿ ÎºÎ¿Î¹Î½ÏŒ

  // spreads (Î¼ÏŒÎ½Î¿ Î¿ÏÎ¹Î¶ÏŒÎ½Ï„Î¹Î±)
  const meetSpreadPx  = 45;   // ÏƒÏ„Î¿ ÎºÎ­Î½Ï„ÏÎ¿
  const splitSpreadPx = 56;   // ÏƒÏ„Î¿ split
  const exitSpreadPx  = 105;  // ÎºÎ¿Î½Ï„Î¬ ÏƒÏ„Î± Ï€ÎµÏ„Î¬ÏƒÎ¼Î±Ï„Î±/Î¼Î­ÏƒÎ± ÏƒÏ„Î± panels

  // ÏƒÏ„ÏŒÏ‡Î¿Î¹ ÎºÎ¯Î½Î·ÏƒÎ·Ï‚
  const centerMeetX  = stageW*0.50;
  const centerPackX  = stageW*0.50;

  const rightEdgeX   = stageW*0.90;
  const rightEdgeX2  = stageW*1.04;
  const leftEdgeX    = stageW*0.10;
  const leftEdgeX2   = -stageW*0.04;

  // deterministic RNG
  let seed = 246813579;
  const rnd = ()=>{
    seed = (seed*1664525 + 1013904223) >>> 0;
    return seed / 4294967296;
  };
  const lerp = (a,b,t)=>a+(b-a)*t;
  const clamp01 = (t)=> (t<0?0:(t>1?1:t));

  const applyPose=(poses)=>{
    for(let i=0;i<n;i++){
      const el=actors[i];
      const P=poses[i];
      if(!P) continue;
      el.style.left = `${P.x}px`;
      el.style.bottom = `${P.b}px`;
      el.style.opacity = '1';
    }
  };

  // Î’ÏÎ¯ÏƒÎºÎ¿Ï…Î¼Îµ â€œÏ„ÏÎ­Ï‡Î¿Ï…ÏƒÎµÏ‚â€ x Î¸Î­ÏƒÎµÎ¹Ï‚ (Î±Ï€ÏŒ left Î® Î±Ï€ÏŒ Î´Î¹Î¬Ï„Î±Î¾Î·)
  const currX = actors.map((el,i)=>{
    const v = parseFloat(el.style.left||'0');
    if(isFinite(v) && v!==0) return v;
    // fallback: Î±Ï€Î»ÏÎ½Î¿Ï…Î¼Îµ Î±ÏÏ‡Î¹ÎºÎ¬ ÏƒÏ„Î· Î¼Î­ÏƒÎ·
    const spread = (i-(n-1)/2) * 34;
    return stageW*0.52 + spread;
  });

  // Î¦Î¬ÏƒÎµÎ¹Ï‚: meet â†’ tighten â†’ split â†’ exit (Î¼ÏŒÎ½Î¿ ÎŸÎ¡Î™Î–ÎŸÎÎ¤Î™Î‘)
  const buildPosesPhase = (phase, t)=>{
    const poses=[];
    for(let i=0;i<n;i++){
      const jitterX = (rnd()-0.5)*3;
      const jitterB = 0; // ÎºÎ±Î¼Î¯Î± ÎºÎ±Ï„Î±ÎºÏŒÏÏ…Ï†Î· ÎºÎ¯Î½Î·ÏƒÎ·

      const xFrom = currX[i];
      let xTo = xFrom;

      // ÎºÎ­Î½Ï„ÏÎ¿ ÏƒÏ…Î½Î¬Î½Ï„Î·ÏƒÎ·Ï‚: Î±Ï€Î»Ï‰Î¼Î­Î½Î¿Î¹ (ÏŒÏ‡Î¹ â€œÏƒÏ„Î¿Î¯Î²Î±â€)
      const meetSpread = (i-(n-1)/2) * meetSpreadPx;
      const meetX1 = centerMeetX + meetSpread;
      const meetX2 = centerMeetX + meetSpread*0.78; // Î»Î¯Î³Î¿ Ï€Î¹Î¿ â€œÎ¼Î±Î¶ÎµÎ¼Î­Î½Î¿Î¹â€ Ï‡Ï‰ÏÎ¯Ï‚ Î½Î± Ï€Î±Ï„Î¬Î½Îµ Î¿ Î­Î½Î±Ï‚ Ï„Î¿Î½ Î¬Î»Î»Î¿Î½

      const goRight = RIGHT_SET.has(i);
      const subset  = goRight ? rightIdxs : leftIdxs;

      // split / exit spreads (Î±Î½Î¬ Î¿Î¼Î¬Î´Î±)
      const spSplit = spreadIn(subset,i,splitSpreadPx);
      const spExit  = spreadIn(subset,i,exitSpreadPx);

      if(phase===0){
        // Ï€ÏÎ¿Ï‚ Ï„Î¿ ÎºÎ­Î½Ï„ÏÎ¿
        xTo = lerp(xFrom, meetX1, t);
      }else if(phase===1){
        // Î¼Î¹ÎºÏÏŒ â€œÎ¼Î¬Î¶ÎµÎ¼Î±â€/Î´Î¹ÏŒÏÎ¸Ï‰ÏƒÎ· ÏƒÏ„Î¿ ÎºÎ­Î½Ï„ÏÎ¿
        xTo = lerp(meetX1, meetX2, t);
      }else if(phase===2){
        // split: 1&2 Î´ÎµÎ¾Î¹Î¬, Î¿Î¹ Ï…Ï€ÏŒÎ»Î¿Î¹Ï€Î¿Î¹ Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬
        const edge = goRight ? rightEdgeX : leftEdgeX;
        xTo = lerp(meetX2, edge + spSplit, t);
      }else{
        // Ï„ÎµÎ»Î¹ÎºÏŒ Î²Î®Î¼Î± Ï€ÏÎ¿Ï‚ Ï€ÎµÏ„Î¬ÏƒÎ¼Î±Ï„Î±/Ï€Î¯ÏƒÏ‰ Î±Ï€ÏŒ panels
        const edge1 = goRight ? rightEdgeX  : leftEdgeX;
        const edge2 = goRight ? rightEdgeX2 : leftEdgeX2;
        xTo = lerp(edge1 + spSplit, edge2 + spExit, t);
      }

      poses.push({x: xTo + jitterX, b: standB + jitterB});
    }
    return poses;
  };

  const strobeBurst = async (phase, frames)=>{
    // ÎºÎ¬Î½Î¿Ï…Î¼Îµ burst flashes, ÎºÎ±Î¹ ÏƒÏ„Î¿ Ï„Î­Î»Î¿Ï‚ ÎºÏÎ±Ï„Î¬Î¼Îµ Ï†ÏÏ„Î± ON
    for(let f=0; f<frames; f++){
      // ÏƒÎºÎ¿Ï„Î¬Î´Î¹: Î±Î»Î»Î¬Î¶Î¿Ï…Î¼Îµ Î¸Î­ÏƒÎ·
      curtain.style.opacity='1';
      const t = frames<=1 ? 1 : (f/(frames-1));
      const poses = buildPosesPhase(phase, t);
      applyPose(poses);
      await TM.sleep(flashOffMs);

      // flash: Î´ÎµÎ¯Ï‡Î½Î¿Ï…Î¼Îµ Ï„Î¿ â€œÎºÎ±ÏÎ­â€
      curtain.style.opacity='0';
      await TM.sleep(flashOnMs);
    }
    // ÏƒÏ„Î¿ Ï„Î­Î»Î¿Ï‚, Ï†ÏÏ„Î± ON Î³Î¹Î± Î½Î± â€œÎ±Î½Î±ÏƒÎ¬Î½ÎµÎ¹â€ Î· ÏƒÏ„Î¹Î³Î¼Î®
    curtain.style.opacity='0';
    await TM.sleep(holdLitMs);

    // ÎµÎ½Î·Î¼ÎµÏÏÎ½Î¿Ï…Î¼Îµ Ï„Î¹Ï‚ currX Î³Î¹Î± Ï„Î·Î½ ÎµÏ€ÏŒÎ¼ÎµÎ½Î· Ï†Î¬ÏƒÎ· (Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯Î± pose Ï„Î·Ï‚ Ï†Î¬ÏƒÎ·Ï‚)
    const posesFinal = buildPosesPhase(phase, 1);
    for(let i=0;i<n;i++) currX[i] = posesFinal[i].x;
  };

  const hideBoardDuringFirstBlack = async ()=>{
    // ÎœÎ±Ï…ÏÎ¿Ï€Î¯Î½Î±ÎºÎ±Ï‚ Ï†Î¿Ï…Î±Î³Î¹Î­: Ï†ÎµÏÎ³ÎµÎ¹ ÎœÎ•Î£Î‘ ÏƒÏ„Î¿ Ï€ÏÏÏ„Î¿ ÏƒÎºÎ¿Ï„Î¬Î´Î¹
    const wrap = document.querySelector('#foyer .wrap');
    if(wrap){
      wrap.classList.add('foyer-board-exit');
      // Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ ÏƒÎºÎ¿Ï„Î¬Î´Î¹ Î´ÎµÎ½ Î¼Î±Ï‚ Î½Î¿Î¹Î¬Î¶ÎµÎ¹ Î½Î± â€œÎ´Î¿ÏÎ¼Îµâ€ animation, Î±Ï€Î»Î¬ Î½Î± ÎµÎ¾Î±Ï†Î±Î½Î¹ÏƒÏ„ÎµÎ¯
      await TM.sleep(520);
      wrap.style.display = 'none';
    }
  };

  const showAct3Fake = ()=>{
    // Fake Act 3 panel with button (non-functional), plus Act 3 titles on signboard
    const teaser = document.getElementById('act3Teaser');
    if(teaser){
      teaser.style.display='none';
      teaser.setAttribute('aria-hidden','true');
    }

    const act3Break = document.getElementById('act3Break');
    if(act3Break){
      act3Break.style.display='flex';
    }

    phase='act3';
    applySignboardForPhase('act3');
  };

  const swapAudienceFinal = ()=>{
    const main = document.querySelector('.audience-main');
    if(main){
      main.src = 'koino_final.png';
      main.alt = 'ÎºÎ¿Î¹Î½ÏŒ (Ï„ÎµÎ»Î¹ÎºÏŒ)';
    }
  };

  const hideAllSpeakers = ()=>{
    actors.forEach(el=>{
      el.style.display='none';
      el.style.opacity='0';
    });
  };

  // --- 1) Î ÏÏÏ„Î¿ ÏƒÎºÎ¿Ï„Î¬Î´Î¹: Ï†ÎµÏÎ³ÎµÎ¹ Î¿ Ï€Î¯Î½Î±ÎºÎ±Ï‚ ---
  curtain.style.opacity='1';
  const boardExitPromise = hideBoardDuringFirstBlack();
  await TM.sleep(preBlackMs);
  await boardExitPromise;

    // --- 2) 4 Ï†Î¬ÏƒÎµÎ¹Ï‚ â€œÏƒÏ„ÏÎ¿Î¼Ï€Î¿-Î²Î®Î¼Î±Ï„Î±â€ Î¼Îµ ÎµÎ½Î´Î¹Î¬Î¼ÎµÏƒÎ¿ Ï†Ï‰Ï„Î¹ÏƒÎ¼ÏŒ ---
  const phaseFrames = [12,5,15,15];

  await strobeBurst(0, phaseFrames[0]);
  await strobeBurst(1, phaseFrames[1]);
  await strobeBurst(2, phaseFrames[2]);
  await strobeBurst(3, phaseFrames[3]);

  // --- 3) Î¤ÎµÎ»Î¹ÎºÏŒ ÏƒÎºÎ¿Ï„Î¬Î´Î¹ â†’ Î±Î»Î»Î±Î³Î­Ï‚ Î“Î™ÎÎŸÎÎ¤Î‘Î™ Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ ÏƒÎºÎ¿Ï„Î¬Î´Î¹ ---
  // Î¤ÎµÎ»Î¹ÎºÏŒ ÏƒÎºÎ¿Ï„Î¬Î´Î¹ â†’ Î±Î»Î»Î±Î³Î­Ï‚ Î“Î™ÎÎŸÎÎ¤Î‘Î™ Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ ÏƒÎºÎ¿Ï„Î¬Î´Î¹ ---
  curtain.style.opacity='1';

  // Î¼Î¹ÎºÏÏŒ buffer ÏÏƒÏ„Îµ Î½Î± Â«Î³ÏÎ¬ÏˆÎµÎ¹Â» Ï„Î¿ Î¼Î±ÏÏÎ¿ Ï€ÏÎ¹Î½ Î±Î»Î»Î¬Î¾Î¿Ï…Î¼Îµ Î¿Ï„Î¹Î´Î®Ï€Î¿Ï„Îµ
  await TM.sleep(120);

  // Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ ÏƒÎºÎ¿Ï„Î¬Î´Î¹: ÎµÎ¾Î±Ï†Î±Î½Î¯Î¶Î¿Î½Ï„Î±Î¹ + Î±Î»Î»Î¬Î¶ÎµÎ¹ Ï„Î¿ ÎºÎ¿Î¹Î½ÏŒ + ÎµÎ¼Ï†Î±Î½Î¯Î¶ÎµÏ„Î±Î¹ Ï„Î¿ â€œfakeâ€ act3
  hideAllSpeakers();
  if(foyerBubble) foyerBubble.style.display='none';
  if(actBubble)   actBubble.style.display='none';

  // Î±Ï†Î®Î½Î¿Ï…Î¼Îµ Î¬Î´ÎµÎ¹Î¿ Ï‡ÏÏÎ¿ + â€œfakeâ€ Ï€ÏÎ¬Î¾Î· 3
  swapAudienceFinal();
  showAct3Fake();

  // ÎºÏÎ±Ï„Î¬Î¼Îµ Ï„Î¿ ÏƒÎºÎ¿Ï„Î¬Î´Î¹ Î»Î¯Î³Î¿ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ Î³Î¹Î± Î½Î± Î¼Î· Ï†Î±Î¯Î½ÎµÏ„Î±Î¹ â€œÏ„Î·Î»ÎµÎ¼ÎµÏ„Î±Ï†Î¿ÏÎ¬â€
  await TM.sleep(finalBlackMs);

  // Ï†ÏÏ„Î± ON: Î¬Î´ÎµÎ¹Î± Î±Î¯Î¸Î¿Ï…ÏƒÎ±
  // fade-in Ï†ÏÏ„Ï‰Î½ (Î¼ÏŒÎ½Î¿ ÏƒÏ„Î¿ Ï„Î­Î»Î¿Ï‚)
  const finalFadeInMs = 320;
  curtain.style.transition = `opacity ${finalFadeInMs}ms linear`;
  curtain.style.opacity='0';
  await TM.sleep(finalFadeInMs);
  curtain.style.transition = 'opacity 0ms linear';

  await TM.sleep(1100);

  // Î²Î³Î±Î¯Î½Î¿Ï…Î¼Îµ Î±Ï€ÏŒ strobe mode (ÎºÏÎ±Ï„Î¬Î¼Îµ Ï„Î·Î½ Ï„ÎµÎ»Î¹ÎºÎ® ÎµÎ¹ÎºÏŒÎ½Î±)
  document.body.classList.remove('strobe-active');
  curtain.style.display='none';
  curtain.style.opacity='1';

  // Exit mask not needed after final shot
  document.body.classList.remove('exit-mask-active');

  // Î´ÎµÎ½ ÎºÎ¬Î½Î¿Ï…Î¼Îµ restore Ï„Ï‰Î½ avatars: Î· Î¹Î´Î­Î± ÎµÎ¯Î½Î±Î¹ ÏŒÏ„Î¹ â€œÎ­Ï†Ï…Î³Î±Î½â€.
  // (ÎºÏÎ±Ï„Î¬Î¼Îµ ÏŒÎ¼Ï‰Ï‚ Ï„Î± orig Î³Î¹Î± Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î± ÏƒÎµ reset, Ï„Î¿ Î¿Ï€Î¿Î¯Î¿ Î¾Î±Î½Î±Ï‡Ï„Î¯Î¶ÎµÎ¹ state Î¿ÏÏ„Ï‰Ï‚ Î® Î¬Î»Î»Ï‰Ï‚)
}

async function foyerBoardExitWithTeaser(){
  const wrap = document.querySelector('#foyer .wrap');
  const teaser = document.getElementById('act3Teaser');
  if(teaser) teaser.style.display = 'block';
  if(wrap){
    wrap.classList.add('foyer-board-exit');
    await TM.sleep(940);
    wrap.classList.remove('foyer-board-exit');
  }
  if(teaser) teaser.style.display = 'none';
}

async function finalEmptySeatsShot(){
  // Î¤ÎµÎ»Î¹ÎºÎ® ÎµÎ¹ÎºÏŒÎ½Î±: â€œÎ¬Î´ÎµÎ¹ÎµÏ‚ ÎºÎ±ÏÎ­ÎºÎ»ÎµÏ‚â€ (Ï‡Ï‰ÏÎ¯Ï‚ Ï„Î¿Ï…Ï‚ Î¿Î¼Î¹Î»Î·Ï„Î­Ï‚ Î¼Ï€ÏÎ¿ÏƒÏ„Î¬)
  if(foyer) foyer.style.display = 'none';
  if(foyerBubble) foyerBubble.style.display='none';
  if(viewersStrip){
    viewersStrip.querySelectorAll('.viewer-avatar').forEach(el=>{
      el.style.opacity='0';
      el.classList.remove('visible');
      el.classList.remove('lit');
    });
  }
  setAudienceLights(true);
  await TM.sleep(900);
}


function showSpeakerChip(idx1based){
  const {x,y,info}=getViewerAvatarCenter(idx1based);
  if(!info) return;
  const nameGR=info.name_gr || ('Î˜ÎµÎ±Ï„Î®Ï‚ '+idx1based);
  const nameEN=info.name_en || ('Viewer '+idx1based);
  const label=currentLang==='en'? nameEN : nameGR;
  actBubble.textContent=label;

  // JSON offsets (Î¼Îµ act-specific overrides, Ï‡Ï‰ÏÎ¯Ï‚ hard clamp)
  const dx = num(info['chipDx_'+phase], num(info.chipDx, 0));
  const dy = num(info['chipDy_'+phase], num(info.chipDy, 0));

  actBubble.style.left=(x+dx)+'px';
  actBubble.style.top =(y-dy)+'px';

  actBubble.style.transform='translateX(-50%)';
  actBubble.style.backgroundColor=tint(info.color,0.9);
  actBubble.style.display='block';
}
function hideSpeakerChip(){
  actBubble.style.display='none';
}

function placeBubble(idx1based,xShift,yOffset){
  const {x,y,info}=getViewerAvatarCenter(idx1based);

  // JSON offsets (Î¼Îµ act-specific overrides, Ï‡Ï‰ÏÎ¯Ï‚ hard clamp)
  const baseDx = info ? num(info['bubbleDx_'+phase], num(info.bubbleDx, 0)) : 0;
  const baseDy = info ? num(info['bubbleDy_'+phase], num(info.bubbleDy, 0)) : 0;

  const dx = baseDx + (xShift||0);
  const dy = baseDy + (yOffset||0);

  bubbleEl.style.left=(x+dx)+'px';
  bubbleEl.style.top =(y-dy)+'px';
}

function typeWriterHTML(el,html,totalMs,done){
  el.innerHTML=html||'';
  const textNodes=[];
  function collect(node){
    if(node.nodeType===3){
      textNodes.push({node,text:node.textContent});
      node.textContent='';
    }else if(node.nodeType===1){
      for(const ch of node.childNodes) collect(ch);
    }
  }
  collect(el);
  const totalChars=textNodes.reduce((s,o)=>s+o.text.length,0)||1;
  const baseMs=(typeof totalMs==='number' && totalMs>0? totalMs:2500);
  const step=Math.max(15,Math.min(80,Math.round(baseMs/totalChars)));
  let i=0;
  (function tick(){
    let rem=i;
    for(const obj of textNodes){
      if(rem>obj.text.length){
        obj.node.textContent=obj.text;
        rem-=obj.text.length;
      }else{
        obj.node.textContent=obj.text.slice(0,rem);
        rem=0;
      }
    }
    i++;
    if(i<=totalChars) TM.setTimeout(tick,step);
    else if(typeof done==='function') done();
  })();
}

function showBubbleForEvent(ev){
  return new Promise(resolve=>{
    const viewer=ev.viewer || 1;
    const base=expandDynTemplate(ev.left||'');
    const html=String(base).replaceAll('\n','<br>');

    if(!html){
      hideSpeakerChip();
      bubbleEl.style.display='none';
      hideAllViewerAvatars();
      resolve();
      return;
    }

    showViewerAvatar(viewer);
    showSpeakerChip(viewer);
    placeBubble(viewer,ev.xShift||0,ev.yOffset||0);

    bubbleEl.style.display='block';
    bubbleEl.style.opacity='0';
    bubbleEl.classList.remove('closing');
    bubbleEl.classList.add('active');
    bubbleEl.style.opacity='1';

    const typeMs =ev.typeMs  || 2500;
    const pauseMs=ev.pauseMs || 800;

    let when = (ev && ev.actionsWhen) ? String(ev.actionsWhen) : 'afterType';
    // Announcement-first: if this step changes b/ratio/params, apply after the line is spoken.
    const _hasParamActions = !!(ev && Array.isArray(ev.actions) && ev.actions.some(a=>a && (a.type==='setRatio' || a.type==='setB' || a.type==='setParams')));
    if(when==='beforeType' && _hasParamActions) when='afterType';
    const doActions = async ()=>{
      try{
        if(ev && Array.isArray(ev.actions)) await window.AAT?.actions(ev.actions);
      }catch(e){ console.error(e); }
    };

    const startTyping = ()=>{
      typeWriterHTML(bubbleTextEl,html,typeMs,()=>{
        const chain = (when === 'afterType') ? doActions() : Promise.resolve();
        chain.then(()=>{
          window.setTimeout(()=>{
            bubbleEl.classList.add('closing');
            TM.setTimeout(()=>{
              bubbleEl.classList.remove('active','closing');
              bubbleEl.style.display='none';
              hideSpeakerChip();
              hideAllViewerAvatars();
              resolve();
            },200);
          },pauseMs);
        });
      });
    };

    if(when === 'beforeType') doActions().then(startTyping);
    else startTyping();
  });
}

/* Î”Ï…Î½Î±Î¼Î¹ÎºÏŒ ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Î¼Îµ {A},{T},{omega},{x0},{phi0},{vSignSymbol},{vSignWord} */
function expandDynTemplate(tpl){
  if(!tpl) return '';
  const x0 = x0Val().toFixed(2);
  const phi0deg = getPhi0Deg();
  const phi0rad = ((phi0deg * Math.PI / 180) % (2*Math.PI) + (2*Math.PI)) % (2*Math.PI);
  const v0 = getV0();
  const vSym = getVSignSymbol(v0);
  const vWord = getVSignWord(v0);
  const m1 = m;
  const D1 = m1*omega*omega;
  const Emech = 0.5*D1*(A_m*A_m);
  const tZero = xtZeroCrossingTime();
  return String(tpl)
    .replaceAll('{A}',A_m.toFixed(2))
    .replaceAll('{T}',T.toFixed(2))
    .replaceAll('{omega}',omega.toFixed(3))
    .replaceAll('{x0}',x0)
    .replaceAll('{phi0}',phi0deg.toFixed(1))
    .replaceAll('{phi0Rad}',phi0rad.toFixed(3))
    .replaceAll('{phi0rad}',phi0rad.toFixed(3))
    .replaceAll('{vSignSymbol}', vSym)
    .replaceAll('{vSignWord}', vWord)
    .replaceAll('{tZero}', tZero.toFixed(2))
    .replaceAll('{m1}', String(Math.round(m1)))
    .replaceAll('{D1}', D1.toFixed(2))
    .replaceAll('{Emech}', Emech.toFixed(2))
    .replaceAll('{EÎ¼Î·Ï‡}', Emech.toFixed(2));
}

function showDynBubble(ev){
  return new Promise(resolve=>{
    const viewer=ev.viewer || 1;
    const base = ev.left || '';
    const txt  = expandDynTemplate(base);

    showViewerAvatar(viewer);
    showSpeakerChip(viewer);
    placeBubble(viewer,ev.xShift||0,ev.yOffset||0);

    bubbleEl.style.display='block';
    bubbleEl.style.opacity='0';
    bubbleEl.classList.remove('closing');
    bubbleEl.classList.add('active');
    bubbleEl.style.opacity='1';

    const typeMs =ev.typeMs  || 2500;
    const pauseMs=ev.pauseMs || 800;

    typeWriterHTML(bubbleTextEl,txt,typeMs,()=>{
      TM.setTimeout(()=>{
        bubbleEl.classList.add('closing');
        TM.setTimeout(()=>{
          bubbleEl.classList.remove('active','closing');
          bubbleEl.style.display='none';
          hideSpeakerChip();
          hideAllViewerAvatars();
          resolve();
        },200);
      },pauseMs);
    });
  });
}


/* ---------- Dialog Actions (minimal, JSON-friendly) ----------
   Optional per-dialog-line field:
     "actions": [ { "type":"setB", "value":12 }, { "type":"setF", "ratio":0.95 } ]
   Runs AFTER the bubble text is typed (default), unless you set:
     "actionsWhen": "beforeType"
-------------------------------------------------------------- */

(function(){
  const AAT = (window.AAT = window.AAT || {});

  function _dispatchChange(el){
    if(!el) return;
    try{ el.dispatchEvent(new Event('change',{bubbles:true})); }catch(e){}
    try{ el.dispatchEvent(new Event('input',{bubbles:true})); }catch(e){}
  }

  AAT.action = async function(action){
    if(!action || typeof action !== 'object') return;
    const type = action.type;

    // Forced oscillator controls (Phase 3)
    if(type === 'setB'){
      if(phase === 'act3' && typeof afBFLocked !== 'undefined' && afBFLocked){
        const raw = Number(action.ratio ?? action.value);
        // Î•Î¾Î±Î¯ÏÎµÏƒÎ·: Î±Î½ ÎµÎ¯Î¼Î±ÏƒÏ„Îµ ÏƒÏ„Î¿ OFF (driveRatio=0) ÎºÎ±Î¹ Î¿Î¹ Î´Î¹Î¬Î»Î¿Î³Î¿Î¹ Î¶Î·Ï„Î¿ÏÎ½ f>0, Î¬ÏƒÎµ Ï„Î·Î½ ÎµÎºÎºÎ¯Î½Î·ÏƒÎ· Î½Î± Î³Î¯Î½ÎµÎ¹.
        if(!(driveRatio === 0 && Number.isFinite(raw) && raw > 0)) return;
      }
      const el = document.getElementById('driveB');
      if(!el) return;
      el.value = String(action.value);
      _dispatchChange(el);
      return;
    }

    if(type === 'setF' || type === 'setRatio'){
      const raw = Number(action.ratio ?? action.value);
      // Act3 ÎµÎ¹Î´Î¹ÎºÏŒÏ‚ ÎºÎ±Î½ÏŒÎ½Î±Ï‚: Î³Î¹Î± b=6 Î”Î•Î ÎµÏ€Î¹Ï‡ÎµÎ¹ÏÎ¿ÏÎ¼Îµ f=f0 (ratioâ‰ˆ1.00). Î¤Î¿ Ï€ÏÎ¿ÏƒÏ€ÎµÏÎ½Î¬Î¼Îµ ÏÏƒÏ„Îµ Î½Î± Î¼Î·Î½ Î¼Ï€Î»Î¿ÎºÎ¬ÏÎ¿Ï…Î½ Î¿Î¹ Î´Î¹Î¬Î»Î¿Î³Î¿Î¹.
      if(phase === 'act3' && typeof driveB !== 'undefined' && Number(driveB) === 6 && Number.isFinite(raw) && Math.abs(raw - 1.0) <= 0.005){
        try{ notifyAFRecorded(); }catch(_e){}
        try{ setAFBFLocked(false); }catch(_e){}
        return;
      }
      if(phase === 'act3' && typeof afBFLocked !== 'undefined' && afBFLocked){
        // Î•Î¾Î±Î¯ÏÎµÏƒÎ·: Î±Î½ ÎµÎ¯Î¼Î±ÏƒÏ„Îµ ÏƒÏ„Î¿ OFF (driveRatio=0) ÎºÎ±Î¹ Î¶Î·Ï„Î¬Î¼Îµ f>0, Î±Ï†Î®Î½Î¿Ï…Î¼Îµ Ï„Î·Î½ ÎµÎºÎºÎ¯Î½Î·ÏƒÎ·.
        const canStart = (typeof driveRatio !== 'undefined' && driveRatio === 0 && Number.isFinite(raw) && raw > 0);
        if(!canStart) return;
      }
      const el = document.getElementById('driveRatio');
      if(!el) return;
      // ratio is numeric like 0.95, 1.15 etc
      el.value = (Number.isFinite(raw) ? raw.toFixed(2) : String(action.ratio ?? action.value));
      _dispatchChange(el);
      return;
    }

    if(type === 'setParams'){
      if(action.b!=null) await AAT.action({type:'setB', value: action.b});
      if(action.ratio!=null) await AAT.action({type:'setF', ratio: action.ratio});
      return;
    }

    if(type === 'sleep'){
      const ms = Math.max(0, (action.ms|0));
      await TM.sleep(ms);
      return;
    }

    
    if(type === 'awaitAFRecord'){
      // Act3 gate: Ï€ÎµÏÎ¯Î¼ÎµÎ½Îµ Î½Î± ÎºÎ±Ï„Î±Î³ÏÎ±Ï†ÎµÎ¯ Î½Î­Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿ Aâ€“f (ÏƒÏ„Î±Î¸ÎµÏÎ¿Ï€Î¿Î¯Î·ÏƒÎ· Ï€Î»Î¬Ï„Î¿Ï…Ï‚)
      await waitNextAFRecord(currentAFKey());
      return;
    }
// future-proof no-ops (won't crash old dialogues)
    if(type === 'setMode' || type === 'record' || type === 'mark'){
      return;
    }
  };

  AAT.actions = async function(actions){
    if(!Array.isArray(actions)) return;
    for(const a of actions) await AAT.action(a);
  };
})();


/* ---------- Act 1 / Act 2 ---------- */

async function runAct1(){
  phase='act1';
  applySignboardForPhase('act1');
  try{ springEl.style.display='block'; }catch(_e){}
  for(const ev of ACT1){
    if(ev.uiPatch)   applySignPatch(ev.uiPatch);
    if(ev.signPatch) applySignPatch(ev.signPatch);
    if(ev.close){
      await closeCurtainToAct2();
      return;
    }

    if(ev.param){
      await showDynBubble(ev);

      if(ev.right){
        addLaw(ev.right);
        if(ev.alsoParams) showParamsBox();
      }

      if(ev.graph==='xt') initXTChart();
      if(ev.plot ==='v') ensureVelocityChart();
      if(ev.plot ==='a') ensureAccelerationChart();
      if(ev.plot ==='ax')ensureAxChart();
      if(ev.plot ==='xsin')ensureXSinChart();

      if(ev.xtZeroMark){
        initXTChart();
        triggerXtZeroMark(ev);
      }

      continue;
    }

    if(ev.left || ev.viewer){
      await showBubbleForEvent(ev);

      if(ev.right){
        addLaw(ev.right);
        if(ev.alsoParams) showParamsBox();
      }

      if(ev.graph==='xt') initXTChart();
      if(ev.plot ==='v') ensureVelocityChart();
      if(ev.plot ==='a') ensureAccelerationChart();
      if(ev.plot ==='ax')ensureAxChart();
      if(ev.plot ==='xsin')ensureXSinChart();

      if(ev.xtZeroMark){
        initXTChart();
        triggerXtZeroMark(ev);
      }

      continue;
    }

    if(ev.right){
      addLaw(ev.right);
      if(ev.alsoParams) showParamsBox();

      if(ev.graph==='xt') initXTChart();
      if(ev.plot ==='v') ensureVelocityChart();
      if(ev.plot ==='a') ensureAccelerationChart();
      if(ev.plot ==='ax')ensureAxChart();
      if(ev.plot ==='xsin')ensureXSinChart();

      if(ev.xtZeroMark){
        initXTChart();
        triggerXtZeroMark(ev);
      }

      await TM.sleep(600);
      continue;
    }

    if(ev.graph==='xt') initXTChart();
    if(ev.plot ==='v') ensureVelocityChart();
    if(ev.plot ==='a') ensureAccelerationChart();
    if(ev.plot ==='ax')ensureAxChart();
    if(ev.plot ==='xsin')ensureXSinChart();

    if(ev.xtZeroMark){
      initXTChart();
      triggerXtZeroMark(ev);
    }
  }
  // Fallback: Î±Î½ Î³Î¹Î± Î¿Ï€Î¿Î¹Î¿Î½Î´Î®Ï€Î¿Ï„Îµ Î»ÏŒÎ³Î¿ Î´ÎµÎ½ Î®ÏÎ¸Îµ ev.close, Ï€ÏÎ¿Ï‡Ï‰ÏÎ¬Î¼Îµ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î±.
  await closeCurtainToAct2();
}

/* Ghost / Act 2 */

function ensureActorFloorBottom(){
  if(actorFloorBottomPx!=null) return;
  const sb=getComputedStyle(actor).bottom;
  const val=parseFloat(sb);
  if(!Number.isNaN(val)) actorFloorBottomPx=val;
}

function ensureGhost(){
  ensureActorFloorBottom();

  if(!ghost){
    const aw=actor.offsetWidth || 144;
    const ah=actor.offsetHeight|| 96;

    ghost=document.createElement('div');
    ghost.id='actorGhost';
    ghost.style.position='absolute';
    ghost.style.zIndex='158';
    ghost.style.pointerEvents='none';
    ghost.style.opacity='0';
    ghost.style.filter='grayscale(1) brightness(1.2)';
    ghost.style.width =aw+'px';
    ghost.style.height=ah+'px';
    ghost.style.bottom=(actorFloorBottomPx ?? 0)+'px';
    ghost.style.display='none';

    const img=document.createElement('img');
    img.src=actor.querySelector('img').src;
    img.style.width='100%';
    img.style.height='auto';
    ghost.appendChild(img);
    stage.appendChild(ghost);
  }
  if(!ghostSpring){
    ghostSpring=document.createElement('img');
    ghostSpring.id='springGhost';
    ghostSpring.src=springEl.src;
    ghostSpring.style.position='absolute';
    ghostSpring.style.transformOrigin='left center';
    ghostSpring.style.zIndex='157';
    ghostSpring.style.pointerEvents='none';
    ghostSpring.style.opacity='0';
    ghostSpring.style.filter='grayscale(1) brightness(1.15)';
    ghostSpring.style.display='none';
    stage.appendChild(ghostSpring);
  }
}

async function runAct2(){
  ensureGhost();
  ghostActive=false;
  ghostVisibility=0;
  if(ghost){
    ghost.style.display='none';
    ghost.style.opacity='0';
  }
  if(ghostSpring){
    ghostSpring.style.display='none';
    ghostSpring.style.opacity='0';
  }

  actBreak.style.display='none';
  stage.classList.add('open');
  setAudienceLights(false);
  phase='act2';
  applySignboardForPhase('act2');

  springEl.style.display='block';
  markerEl.style.opacity='1';
  markerGhostEl.style.opacity='0';

  for(const ev of ACT2){
    if(ev.uiPatch)   applySignPatch(ev.uiPatch);
    if(ev.signPatch) applySignPatch(ev.signPatch);
    if(ev.gStart) ghostActive=true;
    if(ev.gStop)  ghostActive=false;

    if(ev.left || ev.viewer){
      await showBubbleForEvent(ev);

      if(ev.right){
        addLaw(ev.right);
        if(ev.alsoParams) showParamsBox();
      }

      if(ev.graph==='xt') initXTChart();
      if(ev.plot ==='v') ensureVelocityChart();
      if(ev.plot ==='a') ensureAccelerationChart();
      if(ev.plot ==='ax')ensureAxChart();
      if(ev.plot ==='xsin')ensureXSinChart();

      continue;
    }

    if(ev.right){
      addLaw(ev.right);
      if(ev.alsoParams) showParamsBox();

      if(ev.graph==='xt') initXTChart();
      if(ev.plot ==='v') ensureVelocityChart();
      if(ev.plot ==='a') ensureAccelerationChart();
      if(ev.plot ==='ax')ensureAxChart();
      if(ev.plot ==='xsin')ensureXSinChart();

      await TM.sleep(600);
      continue;
    }

    if(ev.graph==='xt') initXTChart();
    if(ev.plot ==='v') ensureVelocityChart();
    if(ev.plot ==='a') ensureAccelerationChart();
    if(ev.plot ==='ax')ensureAxChart();
    if(ev.plot ==='xsin')ensureXSinChart();
  }

  stage.classList.remove('open');
  updateMarbleTrack();
  setAudienceLights(true);
  phase='between2and3';
  window.setTimeout(()=>{
    // auto-advance: Act 2 â†’ Act 3 (Ï‡Ï‰ÏÎ¯Ï‚ ÎºÎ»Î¹Îº)
    act3Break.style.display='none';
    runAct3();
  },1200);
}


async function runAct3(){
  // Act3: Î¾ÎµÎºÎ¹Î½Î¬Î¼Îµ Î¾ÎµÎºÎ»ÎµÎ¯Î´Ï‰Ï„Î¿Î¹ (lock Î¸Î± Î¼Ï€ÎµÎ¹ Î¼ÎµÏ„Î¬ Î±Ï€ÏŒ Î±Î»Î»Î±Î³Î® Ï€Î±ÏÎ±Î¼Î­Ï„ÏÏ‰Î½)
  setAFBFLocked(false);
  act3Break.style.display='none';
  stage.classList.add('open');
  setAudienceLights(false);
  phase='act3';
  applySignboardForPhase('act3');

  // Î•Î»Î±Ï„Î®ÏÎ¹Î¿ Î¿ÏÎ±Ï„ÏŒ ÎºÎ±Î¹ ÏƒÏ„Î·Î½ Î ÏÎ¬Î¾Î· 3
  try{ springEl.style.display='block'; }catch(_e){}
  markerEl.style.opacity='1';

  for(const ev of ACT3){
    if(ev.uiPatch)   applySignPatch(ev.uiPatch);
    if(ev.signPatch) applySignPatch(ev.signPatch);

    if(ev.left || ev.viewer){
      await showBubbleForEvent(ev);

      if(ev.right){
        addLaw(ev.right);
        if(ev.alsoParams) showParamsBox();
      }

      if(ev.graph==='xt') initXTChart();
      if(ev.plot ==='v') ensureVelocityChart();
      if(ev.plot ==='a') ensureAccelerationChart();
      if(ev.plot ==='ax')ensureAxChart();
      if(ev.plot ==='xsin')ensureXSinChart();

      continue;
    }

    if(ev.right){
      addLaw(ev.right);
      if(ev.alsoParams) showParamsBox();

      if(ev.graph==='xt') initXTChart();
      if(ev.plot ==='v') ensureVelocityChart();
      if(ev.plot ==='a') ensureAccelerationChart();
      if(ev.plot ==='ax')ensureAxChart();
      if(ev.plot ==='xsin')ensureXSinChart();

      await TM.sleep(600);
      continue;
    }

    if(ev.graph==='xt') initXTChart();
    if(ev.plot ==='v') ensureVelocityChart();
    if(ev.plot ==='a') ensureAccelerationChart();
    if(ev.plot ==='ax')ensureAxChart();
    if(ev.plot ==='xsin')ensureXSinChart();
  }

  stage.classList.remove('open');
  updateMarbleTrack();
  setAudienceLights(true);
  phase='between3andFoyer';
  TM.setTimeout(()=>{ foyerBreak.style.display='flex'; },1200);
}


/* ---------- ÎšÎ¿Ï…ÏÏ„Î¯Î½ÎµÏ‚ / Î¼ÎµÏ„Î±Î²Î¬ÏƒÎµÎ¹Ï‚ ---------- */

function closeCurtainToAct2(){
  return new Promise(resolve=>{
    stage.classList.remove('open');
  updateMarbleTrack();
    setAudienceLights(true);
    TM.setTimeout(()=>{
      setBookUnlocked(true);
      // auto-advance: Act 1 â†’ Act 2 (Ï‡Ï‰ÏÎ¯Ï‚ ÎºÎ»Î¹Îº)
      actBreak.style.display='none';
      runAct2();
      resolve();
    },1400);
  });
}

/* ---------- Î¦Î¿Ï…Î±Î³Î¹Î­ ---------- */

function isFormulaBlock(text){
  const s=String(text||'').trim();
  if(!s) return false;
  if(/^\(\d+\)/.test(s)) return true;
  if(/[Î‘A]\.[Î”D]\.[ÎœM]\.[Î•E]\.[Î¤T]/.test(s)) return true;
  if(/M\.E\.C/.test(s)) return true;
  if(/[â‡’â‡”]/.test(s)) return true;
  if(/ÎÏŒÎ¼Î¿Ï‚ Ï„Î¿Ï… ÎÎµÏÏ„Ï‰Î½Î±/i.test(s) || /Newtonâ€™s law/i.test(s)) return true;
  return false;
}


function getViewerLabel(info, idx1based){
  const nameGR = (info && info.name_gr) ? info.name_gr : ('Î˜ÎµÎ±Ï„Î®Ï‚ ' + idx1based);
  const nameEN = (info && info.name_en) ? info.name_en : ('Viewer ' + idx1based);
  return (currentLang === 'en') ? nameEN : nameGR;
}

function buildFoyerLineBadge(viewer){
  const vi = viewerInfo(viewer) || {};
  const label = getViewerLabel(vi, viewer);

  const wrap = document.createElement('div');
  wrap.className = 'foyer-line-badge-wrap';

  const badge = document.createElement('span');
  badge.className = 'speaker-badge';

  const av = document.createElement('span');
  av.className = 'speaker-avatar';
  if(vi.img){
    av.style.backgroundImage = 'url("' + vi.img + '")';
    av.textContent = '';
  }else{
    av.style.backgroundImage = '';
    av.textContent = (label || '').trim().slice(0,1).toUpperCase();
  }
  // focus Ï€Î¹Î¿ Ï€Î¬Î½Ï‰ Î³Î¹Î± Ï€ÏÏŒÏƒÏ‰Ï€Î¿ (Ï‡Ï‰ÏÎ¯Ï‚ Î±Î»Î»Î±Î³Î® Î¼ÎµÎ³Î­Î¸Î¿Ï…Ï‚)
  av.style.backgroundPosition = '50% 18%';

  const nm = document.createElement('span');
  nm.className = 'speaker-name';
  nm.textContent = label;

  badge.appendChild(av);
  badge.appendChild(nm);
  wrap.appendChild(badge);
  return wrap;
}

function setFoyerSpeaker(idx1based){
  const {x,y,info}=getViewerAvatarCenter(idx1based);
  if(!info) return;

  const label = getViewerLabel(info, idx1based);

  // Î Î»Î­Î¿Î½ Ï„Î¿ ÏŒÎ½Î¿Î¼Î±/ÎµÎ¹ÎºÎ¿Î½Î¯Î´Î¹Î¿ Î¼Ï€Î±Î¯Î½ÎµÎ¹ Î¼Ï€ÏÎ¿ÏƒÏ„Î¬ ÏƒÎµ ÎºÎ¬Î¸Îµ Î´Î¹Î¬Î»Î¿Î³Î¿ (ÏŒÏ‡Î¹ Î¼ÏŒÎ½Î¹Î¼Î± Ï€Î¬Î½Ï‰ Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬)
  if(foyerSpeakerBadge) foyerSpeakerBadge.style.display = 'none';

  foyerBubble.textContent=label;
  foyerBubble.style.backgroundColor=tint(info.color,0.85);
  foyerBubble.style.borderColor='rgba(255,255,255,.9)';

  const dx=(typeof info.chipDx==='number'? info.chipDx:0);
  const dy=(typeof info.chipDy==='number'? info.chipDy:0);

  foyerBubble.style.left=(x+dx)+'px';
  foyerBubble.style.top =(y-dy)+'px';
  foyerBubble.style.transform='translateX(-50%)';
  foyerBubble.style.display='block';
}


function typeWriterBoard(el,text,totalMs,done){
  const src=String(text||'').replaceAll('sqrt(','âˆš(');
  const total=src.length || 1;
  const baseMs=(typeof totalMs==='number' && totalMs>0? totalMs:3000);
  const step=Math.max(10,Math.round(baseMs/total));
  let i=0;
  (function tick(){
    el.innerHTML=src.slice(0,i).replaceAll('\n','<br>');
    try{ boardLeft.scrollTop=boardLeft.scrollHeight; }catch(e){}
    i++;
    if(i<=src.length) TM.setTimeout(tick,step);
    else if(typeof done==='function') done();
  })();
}

function addFoyerRow(item){
  return new Promise(resolve=>{
    const viewer=item.viewer || 1;
    const vi=viewerInfo(viewer) || {};
    const bgBase=tint(vi.color||'#ffffff',0.22);

    const row=document.createElement('tr');

    const l=document.createElement('td');
    l.className='cell cell-left';
    l.style.width='60%';
    l.style.background=bgBase;
    l.style.borderLeft='4px solid '+tint(vi.color||'#ffffff',0.85);

    const r=document.createElement('td');
    r.className='cell cell-right';
    r.style.width='40%';
    r.style.background=bgBase;
    l.style.verticalAlign='top';
    r.style.verticalAlign='top';
    r.style.borderLeft='4px solid '+tint(vi.color||'#ffffff',0.55);

    row.appendChild(l);
    row.appendChild(r);

    if(foyerTBody){
      foyerTBody.appendChild(row);
    }

    showViewerAvatar(viewer);
    setFoyerSpeaker(viewer);

    // ÎšÎ¬Î¸Îµ Î´Î¹Î¬Î»Î¿Î³Î¿Ï‚ Î¾ÎµÎºÎ¹Î½Î¬ Î¼Îµ â€œÎ˜ÎµÎ±Ï„Î®Ï‚ + ÎµÎ¹ÎºÎ¿Î½Î¯Î´Î¹Î¿â€ (Î¯Î´Î¹Î¿ ÏƒÏ„Ï…Î» Î¼Îµ Ï„Î¿ Î²Î¹Î²Î»Î¯Î¿)
    const lText=document.createElement('div');
    lText.className='foyer-line-text';
    l.appendChild(buildFoyerLineBadge(viewer));
    l.appendChild(lText);

    const rText=document.createElement('div');
    rText.className='foyer-line-text';
    r.appendChild(rText);

    const typeMs =item.typeMs  || 4000;
    const pauseMs=item.pauseMs || 1500;

    typeWriterBoard(lText,item.left||'',typeMs,()=>{
      if((item.right||'').trim().length>0){
        typeWriterBoard(rText,item.right||'',typeMs,()=>{
          TM.setTimeout(resolve,pauseMs);
        });
      }else{
        TM.setTimeout(resolve,pauseMs);
      }
    });
  });
}

async function runFoyer(){
  phase='foyer';
  applySignboardForPhase('foyer');
  setAudienceLights(true);
  foyerEl.style.display='block';
  setFoyerTitles();
  if(startBreak) startBreak.style.display='none';
  startBtn.style.display='none';
  boardLeft.innerHTML='';
  boardRight.innerHTML='';
  foyerBubble.style.display='none';
  if(foyerSpeakerBadge) foyerSpeakerBadge.style.display='none';

  boardLeft.style.gridColumn='1 / span 2';
  boardRight.style.display='none';

  const table=document.createElement('table');
  table.className='foyer-table';
  table.style.width='100%';
  table.style.tableLayout='fixed';
  foyerTBody=document.createElement('tbody');
  table.appendChild(foyerTBody);
  boardLeft.appendChild(table);

  for(const item of FOYER){
    await addFoyerRow(item);
  }
  await runFoyerExitStrobe();
}

/* ---------- ÎšÎ¿Ï…Î¼Ï€Î¹Î¬ / mode ---------- */

function setMode(newMode){
  if(newMode !== 'run' && newMode !== 'pause') newMode = 'run';
  mode = newMode;

  const running = (mode === 'run');
  btnPlay.classList.toggle('active', running);
  btnPause.classList.toggle('active', !running);
  slowHint.textContent = '';

  if(running){
    // Resume all pauseable timers/typewriters
    TM.resume();

    // Avoid time â€œjumpsâ€ after pause
    const now = performance.now();
    lastFrame = now;

    // ÏŒÏ„Î±Î½ Î´ÎµÎ½ Î­Ï‡Î¿Ï…Î¼Îµ Î¾ÎµÎºÎ¹Î½Î®ÏƒÎµÎ¹ Ï€Î±ÏÎ±Ï„Î®ÏÎ·ÏƒÎ·, Ï„Î¿ playbackTime Î²Î±ÏƒÎ¯Î¶ÎµÏ„Î±Î¹ ÏƒÏ„Î¿ t0
    if(!obsStarted){
      t0 = now - playbackTime*1000;
    }

    // countdown: Î¼Î·Î½ â€œÏ†Î¬ÎµÎ¹â€ Ï„Î¿ paused gap
    if(phase === 'countdown' && countdownState.active){
      countdownState.lastNow = now;
    }
  }else{
    TM.pause();
  }
}

btnPause.addEventListener('click',()=>{
  setMode(mode==='pause'?'run':'pause');
});
btnPlay.addEventListener('click',()=>{ setMode('run'); });

/* ---------- Î“ÏÎ®Î³Î¿ÏÎµÏ‚ Î¼ÎµÏ„Î±Î²Î¬ÏƒÎµÎ¹Ï‚ (preview / rewatch) ---------- */

function navReload(start){
  const lang = (currentLang === 'en') ? 'en' : 'gr';
  // ÎÎµÎºÎ¹Î½Î¬Î¼Îµ Î±Ï€ÏŒ ÎºÎ±Î¸Î±ÏÎ® Î´Î¹ÎµÏÎ¸Ï…Î½ÏƒÎ·, Î³Î¹Î± Î½Î± Î¼Î· ÎºÎ¿Ï…Î²Î±Î»Î¬Î¼Îµ Ï€Î±Î»Î¹Î¬ query params.
  const url = new URL(window.location.origin + window.location.pathname);
  url.searchParams.set('start', start);
  url.searchParams.set('lang', lang);
  url.searchParams.set('nav', '1');
  window.location.href = url.toString();
}

function computeNextPhase(){
  if(phase==='act1' || phase==='countdown' || phase==='between1and2') return 'act2';
  if(phase==='act2' || phase==='between2andFoyer') return 'foyer';
  if(phase==='foyer') return 'act1';
  return 'act1';
}

if(btnNext){
  btnNext.addEventListener('click',()=>{ navReload(computeNextPhase()); });
}

if(btnNav && navBreak){
  btnNav.addEventListener('click',()=>{ navBreak.style.display='flex'; });
}
if(navClose && navBreak){
  navClose.addEventListener('click',()=>{ navBreak.style.display='none'; });
}
if(navToAct1){ navToAct1.addEventListener('click',()=>navReload('act1')); }
if(navToAct2){ navToAct2.addEventListener('click',()=>navReload('act2')); }
if(navToFoyer){ navToFoyer.addEventListener('click',()=>navReload('foyer')); }



/* ---------- Î•ÎºÎºÎ¯Î½Î·ÏƒÎ· Î±Ï€ÏŒ URL (start=act1|act2|foyer) ---------- */

function bootFromQuery(){
  let startQ = null;
  let navQ   = null;
  let langQ  = null;
  try{
    const u = new URL(window.location.href);
    startQ = u.searchParams.get('start');
    navQ   = u.searchParams.get('nav');
    langQ  = u.searchParams.get('lang');
  }catch(_e){}

  if(langQ){
    setLanguage(langQ === 'en' ? 'en' : 'gr');
  }

  if(!startQ) return;

  const shouldClean = (navQ === '1');
  const cleanUrl = ()=>{
    try{
      const u = new URL(window.location.href);
      u.searchParams.delete('start');
      u.searchParams.delete('nav');
      // ÎºÏÎ±Ï„Î¬Î¼Îµ Î¼ÏŒÎ½Î¿ Ï„Î¿ lang Î±Î½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹
      const qs = u.searchParams.toString();
      const newUrl = u.pathname + (qs ? ('?' + qs) : '') + u.hash;
      history.replaceState({}, document.title, newUrl);
    }catch(_e){}
  };

  // Î‘Î½ Ï€ÏÏŒÎºÎµÎ¹Ï„Î±Î¹ Î³Î¹Î± â€œÎ³ÏÎ®Î³Î¿ÏÎ· Î¼ÎµÏ„Î¬Î²Î±ÏƒÎ·â€, Î´ÎµÎ½ Î¸Î­Î»Î¿Ï…Î¼Îµ intro/startbreak.
  if(navQ === '1'){
    closeIntro();
  }

  // ÎºÎ±Î¸Î¬ÏÎ¹ÏƒÎ¼Î± overlays
  if(startBreak) startBreak.style.display = 'none';
  if(startBtn)   startBtn.style.display   = 'none';
  if(countdownOverlay) countdownOverlay.style.display = 'none';
  if(actBreak)   actBreak.style.display   = 'none';
  if(foyerBreak) foyerBreak.style.display = 'none';
  if(navBreak)   navBreak.style.display   = 'none';

  // ÎœÎ·Î½ Î±Ï†Î®Î½Î¿Ï…Î¼Îµ â€œÎ¿Ï…ÏÎ­Ï‚â€ Î±Ï€ÏŒ timers
  TM.clearAll();
  countdownState.active = false;

  // reset any exit/strobe leftovers
  document.body.classList.remove('strobe-active','exit-mask-active');
  const act3BreakEl = document.getElementById('act3Break');
  if(act3BreakEl) act3BreakEl.style.display='none';
  const act3TeaserEl = document.getElementById('act3Teaser');
  if(act3TeaserEl){ act3TeaserEl.style.display='none'; act3TeaserEl.setAttribute('aria-hidden','true'); }
  const foyerTitlebarEl = document.getElementById('foyerTitlebar');
  if(foyerTitlebarEl) foyerTitlebarEl.style.display='';
  const aMain = document.querySelector('.audience-main');
  if(aMain){ aMain.src='koino.png'; aMain.alt='ÎºÎ¿Î¹Î½ÏŒ'; }

  // Î•ÎºÎºÎ¯Î½Î·ÏƒÎ· ÏƒÏ„Î¿ Î¶Î·Ï„Î¿ÏÎ¼ÎµÎ½Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿
  if(startQ === 'act1'){
    stage.classList.add('open');
    setAudienceLights(false);
    initShowBase();
    runAct1();
    if(shouldClean) cleanUrl();
    return;
  }

  if(startQ === 'act2'){
    runAct2();
    if(shouldClean) cleanUrl();
    return;
  }

  if(startQ === 'foyer'){
    runFoyer();
    if(shouldClean) cleanUrl();
    return;
  }
}

function resetShow(){
  // ÎºÎ±Î¸Î¬ÏÎ¹ÏƒÎ¼Î± ÏŒÎ»Ï‰Î½ Ï„Ï‰Î½ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼Î­Î½Ï‰Î½ callbacks (Î³Î¹Î± Î½Î± Î¼Î· â€œÏƒÎºÎ¬ÏƒÎ¿Ï…Î½â€ Î¼ÎµÏ„Î¬ Î±Ï€ÏŒ reset)
  TM.clearAll();
  countdownState.active = false;

  // reset any exit/strobe leftovers
  document.body.classList.remove('strobe-active','exit-mask-active');
  const act3BreakEl = document.getElementById('act3Break');
  if(act3BreakEl) act3BreakEl.style.display='none';
  const act3TeaserEl = document.getElementById('act3Teaser');
  if(act3TeaserEl){ act3TeaserEl.style.display='none'; act3TeaserEl.setAttribute('aria-hidden','true'); }
  const foyerTitlebarEl = document.getElementById('foyerTitlebar');
  if(foyerTitlebarEl) foyerTitlebarEl.style.display='';
  const aMain = document.querySelector('.audience-main');
  if(aMain && /koino_final\.png$/i.test(aMain.getAttribute('src')||'')) aMain.src = 'koino.png';

  phase='idle';
  t0=performance.now();
  lastFrame=t0;
  playbackTime=0;
  obsStarted=false;
  obsStartPlaybackOffset=0;
  lastSampleObsTime=-Infinity;
  measureRowIdx=0;
  // --- Driver + driven oscillator reset ---
  driverTheta = DRIVER_THETA0;
  driverDx = 0;
  driverDx0 = 0;
  driveU = 0;
  driveUd = 0;
  driveInited = false;
  baseRefX = null;
  basePrevX = null;
  basePrevV = null;
  BOOK_SAMPLES = [];
  setMode('run');
  // ÎºÏÎ±Ï„Î¬Î¼Îµ Ï„Î¿ Î¾ÎµÎºÎ»ÎµÎ¯Î´Ï‰Î¼Î± Î²Î¹Î²Î»Î¯Î¿Ï… Î±Î½ Î­Ï‡ÎµÎ¹ Î³Î¯Î½ÎµÎ¹ ÏƒÏ„Î¿ Ï€Î±ÏÎµÎ»Î¸ÏŒÎ½
  setBookUnlocked(localStorage.getItem(ACT1_UNLOCK_KEY) === '1', false);

  xtMarkState.active = false;
  xtMarkState.showTail = false;

  if(navBreak) navBreak.style.display='none';
  if(startBreak) startBreak.style.display='flex';
  startBtn.style.display='block';
  countdownOverlay.style.display='none';
  measureBox.style.display='none';
  clockEl.style.display='none';
  markerEl.style.opacity='0';
  markerGhostEl.style.opacity='0';
  paramsBoxEl.style.display='none';
  lawsPane.style.display='none';
  lawsBody.innerHTML='';
  firstLawShown=false;
  lawCharts.innerHTML='';
  vCan=aCan=axCan=xsCan=null;
  actBreak.style.display='none';
  foyerBreak.style.display='none';
  foyerEl.style.display='none';
  if(foyerTitle1) foyerTitle1.textContent='';
  if(foyerTitle2) foyerTitle2.innerHTML='';
  foyerBubble.style.display='none';
  if(foyerSpeakerBadge) foyerSpeakerBadge.style.display='none';
  boardLeft.innerHTML='';
  boardRight.innerHTML='';
  foyerTBody=null;
  bubbleEl.style.display='none';
  bubbleEl.classList.remove('active','closing');
  actBubble.style.display='none';
  measureTBody.innerHTML='';
  hideAllViewerAvatars();

  if(uXT){
    xtChartEl.innerHTML='';
    uXT=null;
  }
  if(xSinChartEl){
    xSinChartEl.innerHTML='';
    xSinChartEl.style.display='none';
  }

  stage.classList.remove('open');
  updateMarbleTrack();
  markerEl.style.left=centerX()+'px';
  markerGhostEl.style.left=centerX()+'px';

  springEl.style.display='none';
  if(ghost){
    ghost.style.display='none';
    ghost.style.opacity='0';
  }
  if(ghostSpring){
    ghostSpring.style.display='none';
    ghostSpring.style.opacity='0';
  }
  ghostActive=false;
  ghostVisibility=0;

  setAudienceLights(true);
  applySignboardForPhase('idle');
}

btnReset.addEventListener('click',resetShow);

/* ---------- Export Î³Î¹Î± Î’Î¹Î²Î»Î¯Î¿ ---------- */

function exportBookDataToStorage(){
  try{
    const x0 = x0Val();
    const phi0deg = getPhi0Deg();
  const phi0rad = ((phi0deg * Math.PI / 180) % (2*Math.PI) + (2*Math.PI)) % (2*Math.PI);
    const tZero = xtZeroCrossingTime(); // âœ… Î¤Î©Î¡Î‘ Î¥Î Î‘Î¡Î§Î•Î™ Î Î¡Î‘Î“ÎœÎ‘Î¤Î™ÎšÎ‘

    const payload = {
      A: A_m,
      T: T,
      omega: omega,
      x0: x0,
      phi0Deg: phi0deg,
      tZero: tZero,
      samples: BOOK_SAMPLES.map(s=>({
        idx: s.idx,
        t: s.t,
        x: s.x
      }))
    };
    localStorage.setItem(BOOK_STORAGE_KEY, JSON.stringify(payload));
  }catch(e){
    console.error('exportBookDataToStorage failed', e);
  }
}

/* Book button: Î±Ï€Î¿Î¸Î®ÎºÎµÏ…ÏƒÎ· + Î¬Î½Î¿Î¹Î³Î¼Î± book.html */

if (btnBook) {
  btnBook.addEventListener('click', () => {
    if(!bookUnlocked) return;
    const lang = (currentLang === 'en') ? 'en' : 'gr';
    exportBookDataToStorage();
    window.open('book.html?lang=' + lang, '_blank');
  });
}

/* ---------- ÎˆÎ½Î±ÏÎ¾Î· Î¼Îµ countdown ---------- */


function initShowBase(){
  stage.classList.add('open');
  setAudienceLights(false);
  if(!obsStarted){
    obsStarted=true;
    obsStartPlaybackOffset=playbackTime;
    // ÎšÎ±Ï„Î±Î³ÏÎ±Ï†Î® Ï„Î¿Ï… t=0, x0 Ï‰Ï‚ Ï€ÏÏÏ„Î· ÎµÎ³Î³ÏÎ±Ï†Î®
    logMeasurement(0, x0Val());
  }
  clockEl.style.display='block';
  measureBox.style.display='block';
  markerEl.style.opacity='1';
  markerGhostEl.style.opacity='0';
  updateRuler();
}

function beginObservation(){
  countdownState.active = false;
  try{ setXTOverlay(true); }catch(_e){}
  initShowBase();
  runAct1();
}

function startShowCountdown(){
  phase='countdown';
  if(startBreak) startBreak.style.display='none';
  startBtn.style.display='none';
  countdownOverlay.style.display='flex';

  const seconds = 5;
  countdownState.active = true;
  countdownState.remainingMs = seconds * 1000;
  countdownState.lastNow = performance.now();

  function tick(){
    if(!countdownState.active || phase !== 'countdown') return;

    const now = performance.now();

    if(mode === 'run'){
      const dtMs = now - countdownState.lastNow;
      countdownState.remainingMs = Math.max(0, countdownState.remainingMs - dtMs);
    }
    countdownState.lastNow = now;

    const remainS = Math.max(0, Math.ceil(countdownState.remainingMs / 1000));
    countdownTimerEl.textContent = remainS;

    if(countdownState.remainingMs <= 0){
      countdownState.active = false;
      countdownOverlay.style.display='none';
      beginObservation();
      return;
    }
    requestAnimationFrame(tick);
  }

  requestAnimationFrame(tick);
}

startBtn.addEventListener('click',startShowCountdown);

btnAct2.addEventListener('click',()=>{
  actBreak.style.display='none';
  runAct2();
});

btnAct3.addEventListener('click',()=>{
  act3Break.style.display='none';
  runAct3();
});

btnFoyerGo.addEventListener('click',()=>{
  foyerBreak.style.display='none';
  runFoyer();
});


/* ---------- Mini x(t) overlay (Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯ÎµÏ‚ ~6 Ï€ÎµÏÎ¯Î¿Î´Î¿Î¹) ---------- */

const XTmini = (()=>{
  let enabled = false;
  let btn=null, cvs=null, ctx=null;
  const samples = [];
  const MAX_SAMPLES = 2600;
  let lastT = 0;

  function bind(){
    if(!btn) btn = document.getElementById('btnXTmini');
    if(!cvs) cvs = document.getElementById('xtMiniCanvas');
    if(cvs && !ctx) ctx = cvs.getContext('2d');

    if(btn && !btn._xtmini){
      btn._xtmini = true;
      btn.addEventListener('click', ()=>{
        enabled = !enabled;
        if(cvs) cvs.style.display = enabled ? 'block' : 'none';
        if(enabled) draw(lastT);
      });
    }
  }

  function periodSec(){
    const r = (typeof driveRatio==='number') ? driveRatio : 0;
    if(r > 0.0001) return T / r;
    return T;
  }

  function windowSec(){
    return Math.min(24, Math.max(3, 6 * periodSec()));
  }

  function add(t, xMeters){
    lastT = t;
    if(!Number.isFinite(t) || !Number.isFinite(xMeters)) return;
    bind();

    // ÎºÏÎ±Ï„Î¬Î¼Îµ displacement Ï‰Ï‚ Ï€ÏÎ¿Ï‚ Ï„Î¿ 10 m
    const xRel = xMeters - RULER_CENTER_M;
    samples.push({t, x:xRel});
    if(samples.length > MAX_SAMPLES) samples.splice(0, samples.length - MAX_SAMPLES);

    const win = windowSec();
    const tMin = t - win - 0.5;
    while(samples.length && samples[0].t < tMin) samples.shift();

    if(enabled) draw(t);
  }

  function draw(tNow){
    if(!enabled || !ctx || !cvs) return;
    const W = cvs.width, H = cvs.height;
    ctx.clearRect(0,0,W,H);

    // frame
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.fillRect(0,0,W,H);

    const padL=44, padR=10, padT=16, padB=26;
    const x0=padL, y0=padT, x1=W-padR, y1=H-padB;
    const w=x1-x0, h=y1-y0;

    const win = windowSec();
    const tStart = tNow - win;
    const pts = samples.filter(p=>p.t >= tStart - 1e-6);

    // y-scale
    let maxAbs = 0.5;
    for(const p of pts) maxAbs = Math.max(maxAbs, Math.abs(p.x));
    const yMax = Math.min(8, Math.max(1, maxAbs*1.12));

    const X = (tt)=> x0 + ((tt - tStart)/win) * w;
    const Y = (xx)=> {
      const u = (xx / yMax);
      return y0 + (0.5 - 0.5*u) * h;
    };

    // axes
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x0, y0 + h/2); ctx.lineTo(x1, y0 + h/2);
    ctx.moveTo(x0, y0); ctx.lineTo(x0, y1);
    ctx.stroke();

    // labels
    ctx.fillStyle = 'rgba(255,255,255,0.82)';
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('x(t) (Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯ÎµÏ‚ ~6 Ï€ÎµÏÎ¯Î¿Î´Î¿Î¹)', x0, 13);
    ctx.font = '10px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.textAlign = 'right';
    ctx.fillText((+yMax.toFixed(1)) + ' m', x0-6, y0+4);
    ctx.fillText((-(+yMax.toFixed(1))) + ' m', x0-6, y1);
    ctx.textAlign = 'left';

    // curve
    if(pts.length >= 2){
      ctx.strokeStyle = 'rgba(80,180,255,0.95)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(X(pts[0].t), Y(pts[0].x));
      for(let i=1;i<pts.length;i++) ctx.lineTo(X(pts[i].t), Y(pts[i].x));
      ctx.stroke();
    }else{
      ctx.fillStyle='rgba(255,255,255,0.70)';
      ctx.fillText('â€”', x0+6, y0 + h/2 + 4);
    }
  }

  return { add, draw, isOn:()=>enabled };
})();

/* ---------- Animation loop ---------- */

function animate(now){
  const realDt=(now-lastFrame)/1000;
  lastFrame=now;
  const dt = (mode==='run') ? realDt : 0;

  updateRuler();
  updateDriverPlacement();

  // Driver motion (Ï€Î±Î³ÏÎ½ÎµÎ¹ ÏƒÏ„Î¿ pause)
  driverTheta += driverOmega * dt;
  if(driverTheta > Math.PI*2) driverTheta -= Math.PI*2;
  applyDriverTransform();

  const tPhys=(now-t0)/1000;
  if(!obsStarted){
    // Ï€ÏÎ¹Î½ Ï„Î·Î½ â€œÏ€Î±ÏÎ±Ï„Î®ÏÎ·ÏƒÎ·â€ Î¸Î­Î»Î¿Ï…Î¼Îµ Î½Î± Ï€Î±Î³ÏÎ½ÎµÎ¹ ÎºÎ¹ Î±Ï…Ï„ÏŒ ÏƒÏ„Î¿ pause
    if(mode==='run') playbackTime=tPhys;
  }else{
    playbackTime+=dt;
  }
  const tObs=obsStarted? (playbackTime-obsStartPlaybackOffset):0;
  clockEl.textContent='t = '+tObs.toFixed(2)+' s';

  ensureActorFloorBottom();
  const bottomPx=actorFloorBottomPx ?? 0;

  const axx=springAnchorX();
  const cx =centerX();
  const stageH=stage.clientHeight;

  // --- Phase 3: driven oscillator with base excitation ---
  // Base (support) position is the left spring anchor (attached to slider)
  const baseX = axx; // px

  // Numerical derivatives for base motion (velocity & acceleration)
  let baseV = 0;
  let baseA = 0;
  if(dt > 0){
    if(basePrevX === null){
      basePrevX = baseX;
      basePrevV = 0;
    }
    baseV = (baseX - basePrevX) / dt;
    if(basePrevV === null) basePrevV = 0;
    baseA = (baseV - basePrevV) / dt;
  }

  // Natural angular frequency of the oscillator (from the original AAT setup)
  const omega0 = omega;

  // Initialize so we don't "jump" when switching from the old SHM demo
  if(!driveInited){
    // Start from the same SHM state used in the original AAT demo, referenced to the ruler zero (cx).
    const xEq = equilibriumXpx();
    const x0 = xEq + A_px*Math.sin(omega*playbackTime);
    const v0 = A_px*omega*Math.cos(omega*playbackTime);

    // Lock y0 at entry and define L0 so that the equilibrium aligns with the ruler zero.
    if(baseRefX === null) baseRefX = baseX; // y0
    const L0 = xEq - baseRefX;

    // u = (x - y) - L0
    driveU  = (x0 - baseX) - L0;
    driveUd = (v0 - baseV);
    driveInited = true;
  }

  // Integrate driven motion (semi-implicit Euler) for:
  //   uÂ¨ + (b/m) uË™ + Ï‰0Â² u = -yÂ¨
  if(dt > 0){
    const beta = (driveB / (2*m)); // 1/s
    const uDD = (-2*beta*driveUd) - (omega0*omega0)*driveU - baseA;

    driveUd += uDD * dt;
    driveU  += driveUd * dt;

    basePrevX = baseX;
    basePrevV = baseV;
  }

  // Absolute (stage) x-position of the actor (center)
  const xEq = equilibriumXpx();
  const L0 = xEq - (baseRefX ?? baseX);
  const hookX = baseX + L0 + driveU;

const baseL=springNaturalWidth || (springEl.getBoundingClientRect().width || 1);
  const dist=hookX-axx;
  const scale=Math.max(0.001, dist/baseL);
  springEl.style.left=axx+'px';
  springEl.style.transform='scaleX('+scale+')';

  const actorRect=actor.getBoundingClientRect();
  const actorWidth=actorRect.width || 80;
  actor.style.bottom=bottomPx+'px';
  actor.style.left=(hookX-actorWidth/2)+'px';

  markerEl.style.left=hookX+'px';
  spotlight.style.background =
    'radial-gradient(220px 140px at '+hookX+'px '+(stageH*0.62)+'px, rgba(255,255,220,0.65), rgba(255,255,255,0) 70%)';

  const xMeters=(hookX-rulerZeroX)/pxPerMeter;
  const fHz = (driverOmega / (2*Math.PI));
  const fRatio = driveRatio;
  if (typeof AFRecorder !== 'undefined') AFRecorder.update({ xMeters, dt, fHz, fRatio, bKgPerS: driveB });
  logMeasurement(tObs,xMeters);
  const xRelMeters = xMeters - 10;
  xtOverlayPushSample(tObs, xRelMeters);
  xtOverlayDraw(dt);

  if(typeof XTmini !== 'undefined' && XTmini) XTmini.add(tObs, xMeters);

  if(ghost && ghostSpring){
    const target=ghostActive?1:0;
    const fadeSpeed=3;
    const step=Math.min(1,fadeSpeed*dt);
    ghostVisibility+= (target-ghostVisibility)*step;
    if(ghostVisibility<0.01 && !ghostActive){
      ghostVisibility=0;
      ghost.style.display='none';
      ghostSpring.style.display='none';
      markerGhostEl.style.opacity='0';
    }else{
      ghost.style.display='block';
      ghostSpring.style.display='block';

      const Aghost_m =5.0;
      const Aghost_px=pxPerMeter*Aghost_m;

      const sinÎ¸=Math.max(-1,Math.min(1,(hookX-cx)/Math.max(1,A_px)));
      const hookXg=cx+Aghost_px*sinÎ¸;

      const springBottom=getComputedStyle(springEl).bottom || 'calc((32 * var(--aat-vh0)) + 92px)';
      const ghostRect=ghost.getBoundingClientRect();
      const ghostWidth=ghostRect.width || actorWidth || 80;

      ghost.style.bottom=bottomPx+'px';
      ghost.style.left  =(hookXg-ghostWidth/2)+'px';

      const distg =hookXg-axx;
      const scaleg=distg/baseL;

      ghostSpring.style.bottom   =springBottom;
      ghostSpring.style.left     =axx+'px';
      ghostSpring.style.height   =springNaturalHeight
        ? (springNaturalHeight+'px')
        : (springEl.getBoundingClientRect().height || 1)+'px';
      ghostSpring.style.transform='scaleX('+scaleg+')';

      const vis=ghostVisibility;
      ghost.style.opacity       =(0.85*vis).toString();
      ghostSpring.style.opacity =(0.9*vis).toString();
      markerGhostEl.style.left  =hookXg+'px';
      markerGhostEl.style.opacity=vis.toString();
    }
  }else{
    markerGhostEl.style.opacity='0';
  }

  // â€œÎœÎ¬ÏÎ¼Î±ÏÎ¿â€ (Act 1 & 2) + ghost Î´Î¿ÎºÏŒÏ‚ (Î¼ÏŒÎ½Î¿ ÏŒÏ„Î±Î½ ÎµÎ¼Ï†Î±Î½Î¯Î¶ÎµÏ„Î±Î¹ Î¿ ghost)
  updateMarbleTrack();

  if(uXT)  drawXTChart();
  if(vCan) drawVelocityChart();
  if(aCan) drawAccelerationChart();
  if(axCan)drawAxChart();
  if(xsCan)drawXSinChart();

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ---------- Avatars Î±Ï€ÏŒ JSON.viewers ---------- */

function initViewersAvatars(){
  const items=viewersStrip.querySelectorAll('.viewer-avatar');
  const stageW=stage.clientWidth || window.innerWidth;

  const leftBand=0.18;
  const widthBand=0.64;
  const baseWidthPx=140;
  const refScale=0.5;

  items.forEach((div,idx)=>{
    const v=VIEWERS[idx];
    if(!v){
      div.style.display='none';
      return;
    }

    if(v.img){
      div.style.backgroundImage='url("'+v.img+'")';
    }
    if(typeof v.heightVh==='number'){
      div.style.height='calc(' + v.heightVh + ' * var(--aat-vh0))';
    }else{
      div.style.height='';
    }
    if(typeof v.avatarDy==='number'){
      div.dataset.baseBottom=v.avatarDy;
      div.style.bottom=v.avatarDy+'px';
    }else{
      div.dataset.baseBottom='';
    }
    if(typeof v.avatarScale==='number'){
      const widthPx=baseWidthPx*(v.avatarScale/refScale);
      div.style.width=widthPx+'px';
    }else{
      div.style.width='';
    }

    const fracDefault=(idx+1)/(items.length+1);
    const xFrac=(typeof v.xFrac==='number')? v.xFrac:fracDefault;
    const x=(leftBand+widthBand*xFrac)*stageW;
    div.style.left=x+'px';

    div.style.display='block';
    div.classList.remove('visible','lit');
  });
}

/* ---------- Î¦ÏŒÏÏ„Ï‰ÏƒÎ· dialogs-*.json ---------- */

async function loadDialogs(){
  try{
    const url=(currentLang==='en')?'dialogs-en.json':'dialogs-gr.json';
    const resp=await fetch(url,{cache:'no-store'});
    if(!resp.ok){
      console.error('Î”Îµ Î²ÏÎ­Î¸Î·ÎºÎµ '+url);
      return;
    }
    const data=await resp.json();
    VIEWERS=data.viewers || [];
    ACT1   =data.act1    || [];
    ACT2   =data.act2    || [];
    ACT3   =data.act3    || [];
    FOYER  =data.foyer   || [];

    if(typeof data.actsAvatarOffset==='number'){
      ACTS_AVATAR_OFFSET=data.actsAvatarOffset;
    }else{
      ACTS_AVATAR_OFFSET=-60;
    }

    if(data.ui) UI=data.ui;
    if(data.uiTitles) UI_TITLES=data.uiTitles;
    applyUITextFromUI();
    applySignboardForPhase();

    initViewersAvatars();
  }catch(e){
    console.error(e);
  }
}

/* ---------- Î‘Î»Î»Î±Î³Î® Î³Î»ÏÏƒÏƒÎ±Ï‚ ---------- */

function setLanguage(lang){
  if(lang===currentLang) return;
  currentLang=lang;

  if(btnLangGR && btnLangEN){
    btnLangGR.classList.toggle('active',currentLang==='gr');
    btnLangEN.classList.toggle('active',currentLang==='en');
  }

  resetShow();

    loadDialogs();
}

/* ---------- Bootstrap ---------- */

window.addEventListener('load',async ()=>{
  btnLangGR=document.getElementById('btnLangGR');
  btnLangEN=document.getElementById('btnLangEN');

  if(btnLangGR){
    btnLangGR.addEventListener('click',()=>setLanguage('gr'));
  }
  if(btnLangEN){
    btnLangEN.addEventListener('click',()=>setLanguage('en'));
  }

  updateRuler();
  measureSpringNaturalSize();
  ensureActorFloorBottom();
  resetShow();
  await loadDialogs();
  bootFromQuery();
});

/* =========================================================
   Aâ€“f recorder (DEV):
   - continuous x/xmin/xmax
   - stable peak-to-peak detection -> record (A, fRatio) per b
   - plot multiple Aâ€“f curves for different b
   Notes:
   - xMeters uses the same ruler scale (0 at rulerZeroX)
   - b has units kg/s in force -b*v, so beta = b/(2m)
   ========================================================= */
const AFRecorder = (() => {
  // Lazy-bind UI nodes because this script executes before the HUD/canvas exist in the DOM.
  let elX=null, elXmin=null, elXmax=null, elA=null, elF=null, elB=null, elStable=null;
  let cvs=null, ctx=null;

  function bind(){
    if(!elX) elX = document.getElementById('mhX');
    if(!elXmin) elXmin = document.getElementById('mhXmin');
    if(!elXmax) elXmax = document.getElementById('mhXmax');
    if(!elA) elA = document.getElementById('mhA');
    if(!elF) elF = document.getElementById('mhF');
    if(!elB) elB = document.getElementById('mhB');
    if(!elStable) elStable = document.getElementById('mhStable');
    if(!cvs){
      cvs = document.getElementById('afCanvas');
      ctx = cvs ? cvs.getContext('2d') : null;
    }
  }

  let t = 0;
  let lastX = null;
  let lastSign = 0;

  let xMin = Infinity;
  let xMax = -Infinity;

  // Live extrema (Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯Î¿ max/min) Î³Î¹Î± Î¿Ï€Ï„Î¹ÎºÎ® ÏƒÏ…Î¼Ï†Ï‰Î½Î¯Î± Î¼Îµ Ï‡Î¬ÏÎ±ÎºÎ±/Î³ÏÎ¬Ï†Î·Î¼Î±
  let liveMin = null;
  let liveMax = null;
  const maxList = [];
  const minList = [];

  // stable logic
  let stable = false;
  let stableHold = 0;
  let lastRecordStamp = -1e9;
  let overLimitHold = 0;

  // per-b curves
  const series = new Map(); // bKey -> [{ratio, A}]
  let yMaxAuto = AMP_LIMIT_METERS; // ÏƒÏ„Î±Î¸ÎµÏÎ® ÎºÎ»Î¯Î¼Î±ÎºÎ± 0..6.5

  // tuning
  const EXTREMA_NEED = 2;
  const STABLE_REL_TOL = 0.08;   // 8% (Ï€Î¹Î¿ Î±Î½ÎµÎºÏ„Î¹ÎºÏŒ)
  const STABLE_ABS_TOL = 0.003;  // 3 mm (ÏÏƒÏ„Îµ Î½Î± Î¼Î·Î½ ÎºÎ¿Î»Î»Î¬ÎµÎ¹ ÏŒÏ„Î±Î½ A ÎµÎ¯Î½Î±Î¹ Î¼Î¹ÎºÏÏŒ)
  const STABLE_HOLD_SEC = 0.5;   // seconds stable before recording
  const MIN_RECORD_GAP = 0.5;    // seconds between recordings
  const XRANGE = [0.60, 1.45];
    const XTICKS = [0.60,0.75,0.90,1.00,1.10,1.20,1.50];
  // warmup (Î±Ï€Î¿Ï†Ï…Î³Î® Ï€ÏÏŒÏ‰ÏÎ·Ï‚ ÎºÎ±Ï„Î±Î³ÏÎ±Ï†Î®Ï‚ Ï€ÏÎ¹Î½ â€œÎºÎ¬Ï„ÏƒÎµÎ¹â€ Ï„Î¿ Ï€Î»Î¬Ï„Î¿Ï‚ â€” ÎµÎ¹Î´Î¹ÎºÎ¬ ÎºÎ¿Î½Ï„Î¬ ÏƒÏ„Î¿Î½ ÏƒÏ…Î½Ï„Î¿Î½Î¹ÏƒÎ¼ÏŒ)
  const WARMUP_CYCLES = 6;       // Ï€ÏŒÏƒÎ¿Î¹ ÎºÏÎºÎ»Î¿Î¹ Î´Î¹Î­Î³ÎµÏÏƒÎ·Ï‚ Î½Î± Ï€ÎµÏÎ¬ÏƒÎ¿Ï…Î½ Ï€ÏÎ¹Î½ ÎµÏ€Î¹Ï„ÏÎ­ÏˆÎ¿Ï…Î¼Îµ ÎºÎ±Ï„Î±Î³ÏÎ±Ï†Î®
  const MIN_WARMUP_SEC = 3.0;    // ÎµÎ»Î¬Ï‡Î¹ÏƒÏ„Î± Î´ÎµÏ…Ï„ÎµÏÏŒÎ»ÎµÏ€Ï„Î± warmup (Î³Î¹Î± Ï€Î¿Î»Ï Ï‡Î±Î¼Î·Î»Î­Ï‚ ÏƒÏ…Ï‡Î½ÏŒÏ„Î·Ï„ÎµÏ‚)

  let lastParamChangeT = 0;      // time of last (f,b) change
  let lastSeenRatio = null;
  let lastSeenBKey  = null;


  function bKeyFrom(b){ return Math.round(b); }

  function ensureSeries(b){
    const k = bKeyFrom(b);
    if(!series.has(k)) series.set(k, []);
    return k;
  }

  function fmt(x, n=3){
    if(!Number.isFinite(x)) return 'â€“';
    return x.toFixed(n);
  }

  function pushMax(x){ maxList.push(x); if(maxList.length>6) maxList.shift(); }
  function pushMin(x){ minList.push(x); if(minList.length>6) minList.shift(); }

  function computeASet(){
    const n = Math.min(maxList.length, minList.length, EXTREMA_NEED);
    if(n < EXTREMA_NEED) return null;
    const mx = maxList.slice(-n);
    const mn = minList.slice(-n);
    return mx.map((v,i)=> (v - mn[i]) / 2);
  }

  function isStableA(Aset){
    const amin = Math.min(...Aset);
    const amax = Math.max(...Aset);
    const amean = Aset.reduce((s,v)=>s+v,0)/Aset.length;
    if(amean <= 1e-9) return false;

    const spread = (amax - amin);
    const tol = Math.max(STABLE_ABS_TOL, STABLE_REL_TOL * amean);
    return spread < tol;
  }

  function alreadyRecorded(k, ratio){
    const arr = series.get(k) || [];
    return arr.some(p => Math.abs(p.ratio - ratio) < 1e-6);
  }

  function recordPoint(k, ratio, A, force=false){
    if(!Number.isFinite(A) || A<=0) return;
    const arr = series.get(k);
    // upsert
    const ex = arr.find(p => Math.abs(p.ratio - ratio) < 1e-9);
    if(ex){
      if(force) ex.A = A;
      return;
    }
    if(!force && alreadyRecorded(k, ratio)) return;
    arr.push({ ratio, A });
    arr.sort((a,b)=>a.ratio - b.ratio);
    // yMaxAuto ÏƒÏ„Î±Î¸ÎµÏÏŒ (0..8)
}

  function pruneTowardResonance(k, capRatio){
    const arr = series.get(k);
    if(!arr || arr.length===0) return;
    const r = Number(capRatio);
    const eps = 1e-9;
    if(r < 1.0){
      // remove points closer to 1 on left: (r, 1)
      for(let i=arr.length-1;i>=0;i--){
        const pr = arr[i].ratio;
        if(pr < 1.0 && pr > r + eps) arr.splice(i,1);
      }
    } else if(r > 1.0){
      // remove points closer to 1 on right: (1, r)
      for(let i=arr.length-1;i>=0;i--){
        const pr = arr[i].ratio;
        if(pr > 1.0 && pr < r - eps) arr.splice(i,1);
      }
    }
  }

  function resetExtrema(){
    maxList.length = 0;
    minList.length = 0;
    xMin = Infinity;
    xMax = -Infinity;
    stableHold = 0;
    stable = false;
    lastX = null;
    lastSign = 0;
  }

  function drawPlot(){
    bind();
    if(!ctx || !cvs) return;

    const W=cvs.width, H=cvs.height;
    ctx.clearRect(0,0,W,H);

    const padL=34, padR=10, padT=18, padB=28;
    const x0=padL, y0=padT, x1=W-padR, y1=H-padB;
    const w=x1-x0, h=y1-y0;

    // legend slots (ÏƒÏ„Î±Î¸ÎµÏÎ­Ï‚ Î¸Î­ÏƒÎµÎ¹Ï‚ Î³Î¹Î± b=6,12,24,30)
    const B_SLOTS = {6:0, 12:1, 24:2, 30:3};

const B_COL = {
  6:  'rgba(255,0,0,0.90)',       // ÎºÏŒÎºÎºÎ¹Î½Î¿
  12: 'rgba(0,200,0,0.90)',       // Ï€ÏÎ¬ÏƒÎ¹Î½Î¿
  24: 'rgba(80,180,255,0.90)',    // Î±Î½Î¿Î¹Ï‡Ï„ÏŒ Î¼Ï€Î»Îµ
  30: 'rgba(255,215,0,0.90)'      // ÎºÎ¯Ï„ÏÎ¹Î½Î¿
};
function colorForB(k){ return B_COL[k] || 'rgba(230,230,230,0.85)'; }

    const legendY = (bk)=> y0 + 14 + ((B_SLOTS[bk] ?? 99) * 14);

    // axes
    ctx.strokeStyle='rgba(255,255,255,0.35)';
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(x0,y1); ctx.lineTo(x1,y1);
    ctx.moveTo(x0,y1); ctx.lineTo(x0,y0);
    ctx.stroke();

    // title/labels
    ctx.fillStyle='rgba(255,255,255,0.85)';
    ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Aâ€“f', x0, 12);
    ctx.fillText('f/fâ‚€', x1-34, H-10);
    ctx.fillText('A (m)', Math.max(4, x0-30), y0+10);

    function X(r){
      const u=(r-XRANGE[0])/(XRANGE[1]-XRANGE[0]);
      return x0 + u*w;
    }
    function Y(A){
      const u=A/yMaxAuto;
      return y1 - u*h;
    }
    // x grid/ticks (Î²Î®Î¼Î± 0.2, 1 Î´ÎµÎºÎ±Î´Î¹ÎºÏŒ)
    ctx.save();
    ctx.font='10px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    const xTickStep = 0.20;
    const xTickStart = Math.ceil(XRANGE[0] / xTickStep) * xTickStep;
    const xTickEnd   = XRANGE[1];

    for(let tr = xTickStart; tr <= xTickEnd + 1e-9; tr += xTickStep){
      const trR = Math.round(tr * 10) / 10; // 1 Î´ÎµÎºÎ±Î´Î¹ÎºÏŒ
      const xx  = X(trR);

      ctx.strokeStyle='rgba(255,255,255,0.10)';
      ctx.beginPath(); ctx.moveTo(xx,y1); ctx.lineTo(xx,y0); ctx.stroke();

      ctx.fillStyle='rgba(255,255,255,0.60)';
      ctx.fillText(trR.toFixed(1), xx-10, y1+16);
    }
    ctx.restore();

    // A_drive (Ï€Î»Î¬Ï„Î¿Ï‚ Î´Î¹ÎµÎ³Î­ÏÏ„Î·) â€” Î³ÏÎ±Î¼Î¼Î® ÏƒÏÎ³ÎºÏÎ¹ÏƒÎ·Ï‚
    if(typeof pxPerMeter === 'number' && pxPerMeter > 0){
      const driveA = Math.abs(driverAmpPx) / pxPerMeter; // ÏƒÎµ m
      const yy = Y(driveA);
      if(Number.isFinite(yy)){
        ctx.save();
        ctx.setLineDash([6,4]);
        ctx.strokeStyle='rgba(255,255,255,0.55)';
        ctx.lineWidth=1.5;
        ctx.beginPath();
        ctx.moveTo(x0,yy); ctx.lineTo(x1,yy);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle='rgba(255,255,255,0.75)';
        ctx.font='10px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.textAlign='right';
        ctx.fillText('A_drive', x1-4, yy-4);
        ctx.restore();
      }
    }

    // y grid/ticks (ÏƒÏ„Î±Î¸ÎµÏÎ¬ 0..8 Î±Î½Î¬ 2)
    ctx.save();
    ctx.font='10px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.textAlign='right';
    for(let A=0; A<=8.0001; A+=2){
      const yy=Y(A);
      ctx.strokeStyle='rgba(255,255,255,0.08)';
      ctx.beginPath(); ctx.moveTo(x0,yy); ctx.lineTo(x1,yy); ctx.stroke();
      ctx.fillStyle='rgba(255,255,255,0.55)';
      ctx.fillText(A.toFixed(0), x0-6, yy+4);
    }
    ctx.restore();


// smooth (monotone cubic Hermite / PCHIP-like) for nicer Aâ€“f curves (visual only)
function drawSmoothMonotone(data){
  const n = data.length;
  if(n < 2) return;

  const xs = data.map(p=>p.ratio);
  const ys = data.map(p=>p.A);

  if(n === 2){
    ctx.beginPath();
    ctx.moveTo(X(xs[0]), Y(ys[0]));
    ctx.lineTo(X(xs[1]), Y(ys[1]));
    ctx.stroke();
    return;
  }

  const h = new Array(n-1);
  const d = new Array(n-1);
  for(let i=0;i<n-1;i++){
    h[i] = xs[i+1] - xs[i];
    d[i] = (ys[i+1] - ys[i]) / h[i];
  }

  const m = new Array(n);
  m[0] = d[0];
  m[n-1] = d[n-2];

  for(let i=1;i<n-1;i++){
    if(d[i-1]*d[i] <= 0){
      m[i] = 0;
    } else {
      const w1 = 2*h[i] + h[i-1];
      const w2 = h[i] + 2*h[i-1];
      m[i] = (w1 + w2) / (w1/d[i-1] + w2/d[i]);
    }
  }

  ctx.beginPath();
  ctx.moveTo(X(xs[0]), Y(ys[0]));

  for(let i=0;i<n-1;i++){
    const hi = h[i];
    const x0 = xs[i], x1 = xs[i+1];
    const y0 = ys[i], y1 = ys[i+1];
    const m0 = m[i], m1 = m[i+1];

    const pxSpan = Math.abs(X(x1) - X(x0));
    const steps = Math.max(8, Math.min(40, Math.round(pxSpan/8)));

    for(let s=1;s<=steps;s++){
      const t = s/steps;
      const t2 = t*t, t3 = t2*t;

      const h00 = 2*t3 - 3*t2 + 1;
      const h10 = t3 - 2*t2 + t;
      const h01 = -2*t3 + 3*t2;
      const h11 = t3 - t2;

      const x = x0 + t*hi;
      const y = h00*y0 + h10*hi*m0 + h01*y1 + h11*hi*m1;

      ctx.lineTo(X(x), Y(y));
    }
  }

  ctx.stroke();
}
    // curves
    const keys = Array.from(series.keys()).sort((a,b)=>a-b);
    keys.forEach((k, idx)=>{
      const data = series.get(k);
      if(!data || data.length===0) return;

      const col = colorForB(k);
      ctx.strokeStyle = col.stroke;
      ctx.fillStyle = col.fill;
      ctx.lineWidth = 2;
            const caps = getCaps(k);
      const hasCap = (caps.leftCap != null) || (caps.rightCap != null);

      // --- Î³ÏÎ±Î¼Î¼Î­Ï‚ ÎºÎ±Î¼Ï€ÏÎ»Î·Ï‚ ---
      // Î“Î¹Î± b=6 Î¸Î­Î»Î¿Ï…Î¼Îµ â€œÎ±ÏƒÏ…Î¼Ï€Ï„Ï‰Ï„Î¹ÎºÎ®â€ Î±Î¯ÏƒÎ¸Î·ÏƒÎ· ÎºÎ¿Î½Ï„Î¬ ÏƒÏ„Î¿ f0:
      // Ï€ÏÎ¿ÏƒÎ¸Î­Ï„Î¿Ï…Î¼Îµ 2 *ÎµÎ¹ÎºÎ¿Î½Î¹ÎºÎ¬* ÏƒÎ·Î¼ÎµÎ¯Î± (Î´ÎµÎ½ ÏƒÏ‡ÎµÎ´Î¹Î¬Î¶Î¿Î½Ï„Î±Î¹ Ï‰Ï‚ ÎºÎ¿Ï…ÎºÎ¯Î´ÎµÏ‚),
      // ÏƒÏ„Î± 0.97 ÎºÎ±Î¹ 1.03 Î¼Îµ A>8, ÏÏƒÏ„Îµ Î¿Î¹ ÎºÎ»Î¬Î´Î¿Î¹ Î½Î± â€œÏ„ÏÎ±Î²Î¬Î½Îµâ€ Ï€ÏÎ¿Ï‚ Ï„Î± Ï€Î¬Î½Ï‰.
      const addAsymptoteVirtuals = (line, side) => {
        if(k !== 6) return line;
        // left side anchor: 0.95 -> add 0.97 with A=8.2
        if(side === 'L' && line.some(p => Math.abs(p.ratio - 0.95) < 1e-6)) {
          line = line.concat([{ratio: 0.97, A: 8.2, virtual: true}]);
        }
        // right side anchor: 1.05 -> add 1.03 with A=8.2
        if(side === 'R' && line.some(p => Math.abs(p.ratio - 1.05) < 1e-6)) {
          line = line.concat([{ratio: 1.03, A: 8.2, virtual: true}]);
        }
        // sort by ratio
        line.sort((a,b)=>a.ratio-b.ratio);
        return line;
      };

      if(!hasCap){
        if(k === 6){
          let leftLine = data.filter(p=>p.ratio < 1.0);
          let rightLine = data.filter(p=>p.ratio > 1.0);
          leftLine = addAsymptoteVirtuals(leftLine,'L');
          rightLine = addAsymptoteVirtuals(rightLine,'R');
          if(leftLine.length>=2) drawSmoothMonotone(leftLine);
          if(rightLine.length>=2) drawSmoothMonotone(rightLine);
        } else {
          if(data.length>=2) drawSmoothMonotone(data);
        }
      } else {
        let leftLine = data.filter(p=>p.ratio < 1.0);
        let rightLine = data.filter(p=>p.ratio > 1.0);
        leftLine = addAsymptoteVirtuals(leftLine,'L');
        rightLine = addAsymptoteVirtuals(rightLine,'R');
        if(leftLine.length>=2) drawSmoothMonotone(leftLine);
        if(rightLine.length>=2) drawSmoothMonotone(rightLine);
      }

      // ÎºÎ¿Ï…ÎºÎ¯Î´ÎµÏ‚ Î¼ÏŒÎ½Î¿ Î³Î¹Î± Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÎ¬ ÏƒÎ·Î¼ÎµÎ¯Î± (ÏŒÏ‡Î¹ virtual)
data.forEach(p=>{
        const xx=X(p.ratio);
        const yy=Y(p.A);
        ctx.beginPath();
        ctx.arc(xx,yy,3,0,Math.PI*2);
        ctx.fill();
      });

      // legend (Î´ÎµÎ¾Î¯ Ï€ÎµÏÎ¹Î¸ÏÏÎ¹Î¿)
      ctx.save();
      ctx.textAlign = 'right';
      ctx.fillStyle = col.text;
      ctx.fillText(`b=${k} kg/s`, x1-4, legendY(k));
      ctx.restore();
    });
  }

  function updateHUD(x, fHz, ratio, b){
    bind();
    if(!elX) return;

    elX.textContent = `${fmt(x,3)} m`;
    const xminShow = (Number.isFinite(liveMin) ? liveMin : xMin);
    const xmaxShow = (Number.isFinite(liveMax) ? liveMax : xMax);
    const aShow = (Number.isFinite(xminShow) && Number.isFinite(xmaxShow)) ? 0.5*(xmaxShow-xminShow) : null;

    elXmin.textContent = (Number.isFinite(xminShow) ? `${fmt(xminShow,3)} m` : 'â€”');
    elXmax.textContent = (Number.isFinite(xmaxShow) ? `${fmt(xmaxShow,3)} m` : 'â€”');
    elA.textContent    = (aShow!==null ? `${fmt(aShow,3)} m` : 'â€”');
    if(b < DRIVE_B_SAFE_MIN){
      elF.textContent = `${fmt(fHz,3)} Hz  (r=${fmt(ratio,2)})`;
    } else {
      elF.textContent = `${fmt(fHz,3)} Hz  (${fmt(ratio,2)} fâ‚€)`;
    }
    elB.textContent = `${fmt(b,1)} kg/s`;

    elStable.textContent = stable ? 'stable' : 'unstable';
    elStable.style.background = stable ? 'rgba(0,255,140,0.18)' : 'rgba(255,255,255,0.08)';
    elStable.style.borderColor = stable ? 'rgba(0,255,140,0.35)' : 'rgba(255,255,255,0.25)';
  }

  function update({ xMeters, dt, fHz, fRatio, bKgPerS }){
    if(!Number.isFinite(xMeters) || !Number.isFinite(dt) || dt<=0) return;
    bind();

    t += dt;

    // detect parameter change even if UI forgets to call onFChange/onBChange
    const bKey = bKeyFrom(bKgPerS);
    if(lastSeenRatio === null) lastSeenRatio = fRatio;
    if(lastSeenBKey  === null) lastSeenBKey  = bKey;
    const changed = (Math.abs(fRatio - lastSeenRatio) > 1e-9) || (bKey !== lastSeenBKey);
    if(changed){
      resetExtrema();
      lastParamChangeT = t;
      lastSeenRatio = fRatio;
      lastSeenBKey  = bKey;
      // Act3: ÎºÎ»ÎµÎ¯Î´Ï‰ÏƒÎµ Ï„Î± b,f Î¼Î­Ï‡ÏÎ¹ Î½Î± ÎºÎ±Ï„Î±Î³ÏÎ±Ï†ÎµÎ¯ ÏƒÏ„Î±Î¸ÎµÏÏŒ Ï€Î»Î¬Ï„Î¿Ï‚ ÏƒÏ„Î¿ Î³ÏÎ¬Ï†Î·Î¼Î±
      setAFBFLocked(true);
    }

    const k = ensureSeries(bKgPerS);

    // warmup gate: Î¼Î·Î½ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹Ï‚ â€œstableâ†’recordâ€ Ï€ÏÎ¹Î½ Ï€ÎµÏÎ¬ÏƒÎ¿Ï…Î½ Î±ÏÎºÎµÏ„Î¿Î¯ ÎºÏÎºÎ»Î¿Î¹
    const warmCycles = (bKey === 6) ? 10 : WARMUP_CYCLES;
    const minWarmSec = (bKey === 6) ? 5.0 : MIN_WARMUP_SEC;
    const stableHoldSec = (bKey === 6) ? 0.9 : STABLE_HOLD_SEC;
    const warmupSec = Math.max(minWarmSec, warmCycles / Math.max(0.001, fHz));

    // running min/max for the current window
    xMin = Math.min(xMin, xMeters);
    xMax = Math.max(xMax, xMeters);

    // velocity sign to detect extrema
    if(lastX === null){
      lastX = xMeters;
      lastSign = 0;
      updateHUD(xMeters, fHz, fRatio, bKgPerS);
      drawPlot();
      return;
    }

    const v = (xMeters - lastX)/dt;
    const sign = v>0 ? 1 : (v<0 ? -1 : lastSign);

    if(lastSign === 1 && sign === -1) pushMax(lastX);
    if(lastSign === -1 && sign === 1) pushMin(lastX);


    // update live extrema ÏŒÏ„Î±Î½ Ï€Î¹Î¬ÏƒÎ¿Ï…Î¼Îµ Î½Î­Î¿ Î±ÎºÏÏŒÏ„Î±Ï„Î¿
    if(maxList.length) liveMax = maxList[maxList.length-1];
    if(minList.length) liveMin = minList[minList.length-1];
    lastX = xMeters;
    lastSign = sign;

    const Aset = computeASet();
    const nowStable = Aset ? isStableA(Aset) : false;

    if((t - lastParamChangeT) < warmupSec){
      stableHold = 0;
      stable = false;
    } else {
      stableHold = nowStable ? (stableHold + dt) : 0;
      
    // --- hard safety: Î±Î½ Ï„Î¿ ÏƒÏ„Î¹Î³Î¼Î¹Î±Î¯Î¿ Ï€Î»Î¬Ï„Î¿Ï‚ Î²Î³Î±Î¯Î½ÎµÎ¹ > 5m (Î¼ÎµÏ„Î¬ Ï„Î¿ warmup), ÎºÎ¬Î½Î¿Ï…Î¼Îµ cap point & ÎºÏŒÎ²Î¿Ï…Î¼Îµ Ï€ÏÎ¿Ï‚ f0 ÎœÎŸÎÎŸ ÏƒÏ„Î·Î½ Î¯Î´Î¹Î± Ï€Î»ÎµÏ…ÏÎ¬ ---
    const Ainst = 0.5 * (xMax - xMin);
    if((t - lastParamChangeT) >= warmupSec && Number.isFinite(Ainst) && Ainst > AMP_LIMIT_METERS){
      overLimitHold += dt;
    } else {
      overLimitHold = 0;
    }

    if(overLimitHold >= 0.25 && (t - lastRecordStamp) >= 0.25){
      // cap point (A=6.5) ÏƒÏ„Î¿ Ï„ÏÎ­Ï‡Î¿Î½ ratio ÎºÎ±Î¹ Ï„ÎµÏÎ¼Î±Ï„Î¹ÏƒÎ¼ÏŒÏ‚ ÎºÎ»Î¬Î´Î¿Ï…
      recordPoint(k, fRatio, AMP_LIMIT_METERS, true);
      pruneTowardResonance(k, fRatio);
      if(typeof applyCapForCurrentBF === 'function') applyCapForCurrentBF(bKgPerS, fRatio);
      lastRecordStamp = t;
      // Act3: Î³ÏÎ¬Ï†Ï„Î·ÎºÎµ ÏƒÎ·Î¼ÎµÎ¯Î¿ â†’ ÏƒÎ®Î¼Î± & Î¾ÎµÎºÎ»ÎµÎ¯Î´Ï‰Î¼Î±
      notifyAFRecorded();
      setAFBFLocked(false);

      // reset extrema Î³Î¹Î± ÎºÎ±Î¸Î±ÏÎ® Î½Î­Î± Î¼Î­Ï„ÏÎ·ÏƒÎ·
      resetExtrema();
      xMin = Infinity; xMax = -Infinity;
      stableHold = 0;
      stable = false;
      overLimitHold = 0;

      updateHUD(xMeters, fHz, fRatio, bKgPerS);
      drawPlot();
      return;
    }

stable = nowStable;
    }

    if(stable && (t - lastParamChangeT) >= warmupSec && stableHold >= stableHoldSec && (t - lastRecordStamp) >= MIN_RECORD_GAP){
      const Aavg = Aset.reduce((s,v)=>s+v,0)/Aset.length;
            if(Aavg > AMP_LIMIT_METERS){
        recordPoint(k, fRatio, AMP_LIMIT_METERS, true);
        pruneTowardResonance(k, fRatio);
        if(typeof applyCapForCurrentBF === 'function') applyCapForCurrentBF(bKgPerS, fRatio);
      } else {
        recordPoint(k, fRatio, Aavg);
      }
      lastRecordStamp = t;
      // Act3: Î³ÏÎ¬Ï†Ï„Î·ÎºÎµ ÏƒÎ·Î¼ÎµÎ¯Î¿ â†’ ÏƒÎ®Î¼Î± & Î¾ÎµÎºÎ»ÎµÎ¯Î´Ï‰Î¼Î±
      notifyAFRecorded();
      setAFBFLocked(false);

      // reset window so the live xmin/xmax reflect the next steady-state segment
      xMin = Infinity;
      xMax = -Infinity;
      stableHold = 0;
    }

    updateHUD(xMeters, fHz, fRatio, bKgPerS);
    drawPlot();
  }

  function onBChange(){ resetExtrema(); }
  function onFChange(){ resetExtrema(); }

  return { update, onBChange, onFChange };
})();


</script>

  <!-- === Measurement HUD + Aâ€“f plot (DEV) === -->
  <div id="measureHUD" aria-hidden="true">
    <div class="mh-row">
      <div class="mh-title">ÎœÎµÏ„ÏÎ®ÏƒÎµÎ¹Ï‚</div>
      <div class="mh-chip" id="mhStable">unstable</div>
    </div>
    <div class="mh-grid">
      <div class="mh-k">x</div><div class="mh-v" id="mhX">â€“</div>
      <div class="mh-k">xmin</div><div class="mh-v" id="mhXmin">â€“</div>
      <div class="mh-k">xmax</div><div class="mh-v" id="mhXmax">â€“</div>
      <div class="mh-k">A</div><div class="mh-v" id="mhA">â€“</div>
      <div class="mh-k">f</div><div class="mh-v" id="mhF">â€“</div>
      <div class="mh-k">b</div><div class="mh-v" id="mhB">â€“</div>
    </div>
    <div class="mh-note">ÎŸÏÎ¹ÏƒÎ¼ÏŒÏ‚: A = (xmax âˆ’ xmin)/2. ÎšÎ±Ï„Î±Î³ÏÎ±Ï†Î® ÏŒÏ„Î±Î½ Ï„Î¿ peak-to-peak ÏƒÏ„Î±Î¸ÎµÏÎ¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹.</div>
  </div>
  <canvas id="afCanvas" width="260" height="330" aria-hidden="true"></canvas>

</body>
</html>
